{
	"nodes":[
		{"chat_role":"assistant","id":"904e6ce4ebcaf63b","type":"text","text":"This problem typically arises due to use of fixed units like pixels (`px`) rather than relative units such as viewport height (`vh`), viewport width (`vw`), or percentage (`%`). Fixed units ignore the screen size which can lead to issues at different resolutions, while relative units adjust according to screen size, leading to a more responsive layout. \n\nHere are a few suggestions you might consider:\n\n1. Replace fixed units `px` with relative units like `vh`, `vw` or `%` in classes such as `w-1/4`, `h-1/2`, `mt-24`, `mt-16`, `mr-60`, etc.\n\n2. Update `transform: scale` values and use media queries if necessary to adjust the scale at different resolution points\n\n3. Use Bootstrap, Flexbox, or CSS Grid for layout management\n\n4. Use media queries to apply different styles for different device widths\n\n5. Use a responsive design framework like Bootstrap or Material-UI if it fits into your project\n\n6. Test your page in different resolutions after applying changes to verify the issue is resolved.","x":-581,"y":1376,"width":360,"height":402,"color":"6"},
		{"id":"Proofs of Knowledge/Study Questions/New Questions/202311141423.md","type":"file","file":"Proofs of Knowledge/Study Questions/New Questions/202311141423.md","x":-1189,"y":-864,"width":500,"height":1201,"color":"1"},
		{"id":"af0b4c2b1a58b070","type":"file","file":"Proofs of Knowledge/Engrams/Data Cache/How EAS Works - Ethereum Attestation Service.md","x":-408,"y":-959,"width":400,"height":400},
		{"id":"67b0c5c2b9c64f8c","type":"file","file":"Proofs of Knowledge/Engrams/Data Cache/Memento Mori Summary.md","x":-317,"y":-331,"width":400,"height":400},
		{"id":"978e6a1c32e34788","type":"text","text":"Summarize the provided context ","x":442,"y":-842,"width":448,"height":436},
		{"id":"90a24c77a9b132d6","type":"text","text":"execute your purpose","x":322,"y":-302,"width":320,"height":296},
		{"chat_role":"assistant","id":"3eca90d6674a22d2","type":"text","text":"To solve the context, we can outline a potential process to establish a Proof of Adventure for the WoW Memento Mori NFTs using the Ethereum Attestation Service (EAS). \n\nProcess to create a Proof of Adventure for WoW Memento Mori NFTs using the EAS:\n\n1. **Define the Attestation Schema:** First, we'd need to create a schema to represent the structure of the attestations for each NFT. This schema might include game-specific attributes like character name, character level, time of demise, cause of death, server details, achievement tokens, and any other relevant metadata that will form the essence of the NFT. This schema would be submitted to the EAS Schema Registry Contract and a unique identifier (UID) would be assigned.\n\n2. **Attestation Creation:** Upon a character's death, the defined schema would be filled with the particular details of the event, effectively creating an attestation. The filled schema would be signed by an authorised entity (e.g., the game server in real-time, upon the character's death). This signed attestations data, along with the schema's UID, would be submitted to the EAS Attestation Contract.\n\n3. **Blockchain Record and Verification:** Once submitted, the Attestation Contract would verify the data against the schema and store the attestation on the blockchain. This serves as an immutable record of the player's journey and can be verified by anyone, using the signature and the publicly available UID.\n\n4. **NFT Creation and Association:** With the attestation stored on the blockchain, an NFT can be minted to commemorate the player's adventure. The NFT would include a reference to the attestation (its UID) and be linked to the player's blockchain address, making it a unique and verifiably authentic token of achievement.\n\n5. **Revocation (Optional):** In cases where the attestation data needs to be updated or invalidated (for instance, erroneous data entry), the EAS provides the function to revoke attestations. The original record would remain, but its status changes, which ensures transparency and trust.\n\nThis process would enable each Memento Mori NFT to provide a verifiable proof of the player's adventure, making the NFT more trustworthy and potentially more valuable. \n\nHowever, this is an initial conceptualization, and it would require further refinement and technical implementation. In addition, it is necessary to work closely with the stakeholders to ensure that the system meets their requirements and expectations.","x":-2092,"y":2364,"width":831,"height":1208,"color":"6"},
		{"chat_role":"assistant","id":"3f1fe987678ed549","type":"text","text":"To ensure successful verification of offchain attestations for the NFT drop, collective and incremental verification procedures can be used. Here's how it can work.\n\n**Integrating Offchain Attestations:**\n\nWith the Ethereum Attestation Service (EAS) schema in place, data of player's adventures (character name, level, time of demise, server detail, achievement tokens, etc) can be signed offchain by the authorized entity (like game servers). These signatures would then be linked to the attestations for each NFT marking a unique digital signature.\n\n**Collective Verification for NFT Drop:**\n\nFor a collective verification during the NFT drop:\n\n1. **Batch Verification:** The offchain attestations could be collected in batches corresponding to an NFT drop, each signed by the same authorized key. This allows the batch to be verified collectively, drastically reducing gas fees.\n\n2. **Merkle Tree Structure:** For a more scalable solution, all offchain attestations for an NFT drop could be organized in a Merkle Tree. The root of this tree would then be posted onchain. Individual offchain attestations can be proven correct with the Merkle proof connected to the on-chain root. This provides a viable way for a potentially large number of offchain attestations to be acknowledged en masse by the EAS smart contract during the NFT drop.\n\n3. **On-Chain Events:** During the NFT drop, for every newly minted NFT, an event can be emitted marking the NFT's new owner and the link (hash of the attestation) to the verified offchain data.\n\nBy incorporating this strategy into the blockchain, the authenticity and legitimacy of each NFT within the drop are ensured, enhancing the overall trust and value of the NFTs.\n","x":-1610,"y":2447,"width":997,"height":1348,"color":"6"},
		{"id":"85e876fabf8c608e","type":"text","text":"explain how offchain attestations can be verified collectively for the nft drop\n","x":-1087,"y":2776,"width":250,"height":60},
		{"id":"cdc50170fe26b2bc","type":"text","text":"Help me design an attestation schema that will be consumed when minted im using a merkle tree to verify all proofs at once","x":-503,"y":2393,"width":250,"height":60},
		{"chat_role":"assistant","id":"749e9db9eb109db2","type":"text","text":"Designing an attestation schema that will be verified using a Merkle tree involves defining the data structure that will be included in each leaf node of the tree.\n\nGiven that you're using this for World of Warcraft's 'Memento Mori' NFTs, we might include following attributes in our schema:\n\n1. `characterName`: The name of the WoW character.\n2. `characterClass`: e.g., Warrior, Mage, etc.\n3. `characterRace`: e.g., Orc, Elf, etc.\n4. `characterLevel`: The level of the character at the time of their demise.\n5. `gameServer`: The server on which the character was played.\n6. `timeOfDeath`: The timestamp marking when the character died.\n7. `causeOfDeath`: Details about what caused the character's death.\n8. `achievementTokens`: Any achievement tokens that the character earned.\n\nOur base data structure in Solidity might look like this:\n\n```javascript\nstruct AttestationData {\n    string characterName;\n    string characterClass;\n    string characterRace;\n    uint16 characterLevel;\n    string gameServer;\n    uint64 timeOfDeath;\n    string causeOfDeath;\n    string[] achievementTokens;\n}\n```\n\nThe `AttestationData` structures are then hashed individually to create the leaf nodes of your Merkle tree. Once your Merkle tree is constructed, it's root ‚Äì a single hash representing all the attestation data ‚Äì is what's stored on-chain during the NFT drop.\n\nRemember, anyone can then use a specific `AttestationData` along with the correct Merkle proof (a list of hash siblings up the tree) to verify the attestation was part of the group that was submitted on-chain.\n\nIt's important to note that these leaves should not include any sensitive personal information, as the data can be associated with a real-world identity, even when hashed into a Merkle tree. Always respect privacy standards and conduct appropriate data diligence.","x":-463,"y":2541,"width":747,"height":1206,"color":"6"},
		{"chat_role":"assistant","id":"f26c139fa4164532","type":"text","text":"The provided context discusses two primary elements:\n\n1. Ethereum Attestation Service (EAS)\n   - EAS is a service that facilitates the establishment and management of trust online. At its core, it operates through two contracts, namely the Schema Registration Contract and the Attestation Contract. Schemas are essentially blueprints or templates that define the structure and format of the data one wants to attest to. They are first defined and then submitted to the Schema Registry Contract, which assigns unique identifiers to each schema. Attestations, on the other hand, are digital approvals on data. They are informed by the schemas and are created via the Attestation Contract. Both these contracts allow for the creation and potential revocation of attestations.\n\n2. WoW Memento Mori NFTs project\n   - This project aims to commemorate the journeys and sacrifices of hardcore World of Warcraft (WoW) characters through a series of non-fungible tokens (NFTs) called \"Memento Mori\". The NFTs capture the final moments of these hardcore characters and are supplemented by an immersive virtual memorial platform, achievement tokens, and community-driven events. The project is currently in its requirement analysis phase, seeking to understand the needs of various stakeholders like the players, collectors, and the broader gaming community.\n\nThe received study question pertains to bridging these two elements. Specifically, it inquires about how EAS may be leveraged to establish a Proof of Adventure for the WoW Memento Mori NFTs. Therefore, one of the tasks would be to explore how attestations via EAS could serve to authenticate, verify, or add value to the intended NFTs.","x":-2520,"y":972,"width":841,"height":781,"color":"6"},
		{"chat_role":"assistant","id":"0a8ff82caaac40a9","type":"text","text":"The context provided includes two separate pieces of data. The first describes the Ethereum Attestation Service (EAS). EAS is essentially a method for establishing trust online through attestations or \"digital stamps of approval\" structured around defined schemas. The system enables entities to vouch for particular information, and this attestation is recorded on the blockchain for verification. The process involves defining the schema, registering it with the Schema Registry Contract, and then using this schema to structure, sign, and verify attestations. \n\nThe second piece of context is a project understanding of the WoW Memento Mori NFTs. This project aims to create unique commemorative NFTs for fallen WoW hardcore characters, offering players a way to honor their characters and deepen their commitment. Core features include an immersive virtual memorial platform, achievement tokens, and community-driven events. The challenges and constraints of the project need to be clarified and a detailed plan drawn up based on stakeholder needs and requirements. \n\nBoth pieces of context revolve around the theme of trust and validation but in different domains. The EAS focuses on establishing trust on the blockchain while the NFT project aims to deepen player commitment in a gaming community. Both themes share common ground in demonstrating the importance and relevance of digital trust and validation mechanisms in online communities.","x":-2223,"y":1002,"width":360,"height":575,"color":"6"},
		{"chat_role":"assistant","id":"a417d417ac1f8ee7","type":"text","text":"The provided context includes two pieces of information related to different subjects:\n\n1. **Ethereum Attestation Service**: It describes the working of the Ethereum Attestation Service (EAS). The EAS operates on two primary principles: registering a schema and making attestations. Schemas structure the data that is to be attested to or approved. An attestation is a digitally signed stamp of approval on a certain piece of data, indicating that one entity vouches for that information. All this can become part of the Ethereum blockchain through contracts, making it verifiable by anyone.\n\n2. **WoW Memento Mori NFTs**: It is an analysis of a project aiming to create unique NFTs (Non-fungible Tokens) that commemorate the adventures and sacrifices of hardcore characters in the game World of Warcraft. The NFTs are called \"Memento Mori\". Features of this project include creating unique NFTs representing significant moments in gameplay, a virtual memorial platform for immersive experience, provision for transferring legacy, and community engagement through events and more. \n\nThe context doesn't appear to link these two topics together as of yet, but the question is to determine how the Ethereum Attestation Service can be used to establish a \"Proof of Adventure\" for the WoW Memento Mori project.","x":-1383,"y":1002,"width":648,"height":710,"color":"6"},
		{"id":"336dc328d6e26549","type":"text","text":"Solve the context","x":-2186,"y":1690,"width":448,"height":436},
		{"id":"551c2fb977ca9fd3","type":"file","file":"Proofs of Knowledge/Engrams/Data Cache/Make an Attestation - Ethereum Attestation Service.md","x":2187,"y":863,"width":264,"height":239},
		{"id":"11d88c52bd0e80cb","type":"file","file":"Proofs of Knowledge/Engrams/Data Cache/Create a Schema - Ethereum Attestation Service.md","x":2507,"y":1273,"width":487,"height":420},
		{"id":"238ffa58444174db","type":"file","file":"Proofs of Knowledge/Engrams/Data Cache/Storing Offchain Attestations - Ethereum Attestation Service.md","x":1968,"y":1212,"width":418,"height":367},
		{"id":"b4f06a79a75cb737","type":"text","text":"Help me implement the attestation mechanism in my current application","x":241,"y":1846,"width":260,"height":183},
		{"chat_role":"assistant","id":"d9acb1f5ad1201d7","type":"text","text":"Implementing an attestation mechanism in your current application involves several steps. It requires updating your smart contracts to handle attestations and also making changes to your application's frontend to collect and send the relevant data. Here's a step-by-step guide on how to do it:\n\n1. **Schema and Attestation Data Structure**: Define a struct in your Solidity contract similar to the `AttestationData` struct we defined earlier.\n\n```javascript\nstruct AttestationData {\n    string characterName;\n    string characterClass;\n    string characterRace;\n    uint16 characterLevel;\n    string gameServer;\n    uint64 timeOfDeath;\n    string causeOfDeath;\n    string[] achievementTokens;\n}\n```\n2. **Attestation Contract**: Write an Attestation contract that, among other things, verifies the Merkle proof associated with submitted attestations.\n\nHere's an example of a smart contract function that verifies Merkle proofs. This function uses the precompiled `sha256` function available in Solidity to hash data.\n\n```javascript\nfunction verifyProof(bytes32 _root, bytes32 _leaf, bytes32[] memory _proof) public pure returns (bool) {\n    bytes32 hash = _leaf;\n    \n    for (uint i = 0; i < _proof.length; i++) {\n        bytes32 proofElement = _proof[i];\n\n        if (hash < proofElement) {\n            hash = sha256(abi.encodePacked(hash, proofElement));\n        } else {\n            hash = sha256(abi.encodePacked(proofElement, hash));\n        }\n    }\n    \n    return hash == _root;\n}\n```\n\nThe `_root` is the root of your Merkle tree. `_leaf` is the hashed version of the attestations data for one WoW character. `_proof` is an array containing the list of siblings up to the root of the tree from the leaf.\n\n3. **Implement On-Chain Interaction**: On the front-end side, create an interaction that triggers the transactions to the Attestation contract. It will collect attestation data, hash it, construct and submit the Merkle proof.\n\n4. **NFT minting**: Once an attestation has been checked and verified on-chain, the NFT can be minted. This can be done from the same contract or from a separate NFT contract.\n\nRemember to test your smart contracts throughly before deploying them live. Use development frameworks like Truffle or Hardhat to write tests in JavaScript/TypeScript.\n\nIn your app's frontend, you might use a library like ethers.js or web3.js to interact with your smart contracts. These libraries provide APIs for things like contract deployment and interaction, transaction sending and signing, and more.\n\nThis is a basic outline of how an attestation scheme can be integrated into an application and how it interacts with the NFT minting process. The exact details may vary based on your specific application requirements.","x":598,"y":2257,"width":705,"height":1289,"color":"6"},
		{"id":"197d6f5fb901c150","type":"text","text":"I first want to include the attestation submission in the database routes, my goal is to hold the offchain attestation alongside with the rest of the data ","x":1385,"y":1975,"width":250,"height":375},
		{"chat_role":"assistant","id":"2ebce47ed2acac41","type":"text","text":"Certainly, storing the offchain attestation data alongside the rest of the data in the database is a good approach. Here are the steps to do this:\n\n1. **Define Attestation Data Structure**: Map out the structure of your attestation data to reflect what will be stored in the database. Keep this consistent with the schema we've already defined for the blockchain.\n\n2. **Create Database Schema**: Based on the structure of the attestation data, create a database schema to store the information. Depending on your database choice (e.g., MongoDB, PostgreSQL or Firebase), this process will look different. Your database schema could look something like this.\n\n```javascript\nAttestation {\n   characterName: String,\n   characterClass: String,\n   characterRace: String,\n   characterLevel: Number,\n   gameServer: String,\n   timeOfDeath: Date,\n   causeOfDeath: String,\n   achievementTokens: Array,\n   merkleProof: Array, // hash of the attestation data\n   merkleRoot: String  // root hash of the merkle tree\n}\n```\n\n3. **API Endpoint for Attestation Submission**: Design an API endpoint in your application to allow the submission of attestation data. This endpoint will accept the attestation data as part of the request, perform any necessary verification or validation processes, and then store the data in the database.\n\n```javascript\napp.post('/submitAttestation', (req, res) => {\n   // Validate the incoming attestation data\n   // ...\n\n   // If the data is valid, store it in the database\n   // ...\n});\n```\n\n4. **Integration with Front End**: Integrating the new attestation submission endpoint with the frontend will be necessary. This involves adding a new action in your application's UI which will call the endpoint, pass the attestation data, and then handle the response.\n\n5. **Display Attestation Data**: As attestations are successfully submitted to your database, display the relevant data within the application to the relevant users or stakeholders. This might be on a user profile page, a dashboard, or a separate part of your application intended for displaying and interacting with the user's attestations.\n\nRemember to maintain best practices for data security, ensuring that any sensitive information is appropriately hashed or encrypted both in transit and at rest. As both attestations and the NFT minting process involve interactions with blockchain networks, also ensure you're safely handling any private keys and other sensitive data involved in these processes.","x":1385,"y":2410,"width":685,"height":1587,"color":"6"},
		{"id":"9bc042f5a1121982","type":"text","text":"```html\n  return (\n    <>\n      <div className=\"fixed w-full h-full\">\n        <Image\n          src=\"/mmoriball3.png\"\n          fill\n          alt=\"mmoriball\"\n          className=\"-mt-12 transform -translate-y-1/6 scale-75 scale-y-125 scale-x-90\"\n        />\n        <div\n          className=\"overflow-hidden rounded-full fixed h-1/2 w-1/4 top-2 left-1/2 transform scale-150 -translate-x-1/2 translate-y-1/3 z-10 shadow-xl shadow-black\"\n          style={{\n            opacity: \"1\",\n            scale: \"1\",\n            backgroundImage: \"url('/mmoriball.png')\",\n            backgroundSize: \"cover\",\n            backgroundRepeat: \"no-repeat\",\n            backgroundPosition: \"center\",\n          }}\n        >\n          <Image\n            src=\"/mmoriball2.png\"\n            fill\n            alt=\"mmoriball\"\n            object-fit=\"cover\"\n            style={{\n              animation: \"pulse 1s infinite alternate\",\n              opacity: \"0.65\",\n              position: \"absolute\",\n              zIndex: 1,\n              scale: \"1.05\",\n            }}\n          />\n          {/* this is the text in the background */}\n          <div className=\"mt-24 h-full relative flex overflow-hidden font-mono z-50\">\n            {database?.map((character: any, index: number) => (\n              <>\n                <div className=\"mt-0 -translate-y-1/2 animate-marquee whitespace-nowrap text-black h-full w-max \">\n                  {\" \"}\n                  <div\n                    key={Math.floor(Math.random() * database.length)}\n                    className=\"text-2xl  drop-shadow-lg shadow-inherit\"\n                  >\n                    <span className={playerColor(character)}>\n                      {\" \"}\n                      {character?.name} <br />\n                      <span className=\"text-black\"> Level {character?.level} </span>\n                      {character?.race} {character.class}\n                    </span>\n                  </div>\n                </div>\n                <div className=\"mt-4  animate-marquee whitespace-nowrap text-black h-full w-max \">\n                  {\" \"}\n                  <div key={Math.floor(Math.random() * database.length)} className=\"text-3xl\">\n                    <span className={playerColor(character)}>\n                      {\" \"}\n                      {character?.name} <br />\n                      <span className=\"text-black\"> Lvl {character?.level} </span>\n                      {character?.race} {character.class}\n                    </span>\n                  </div>\n                </div>\n                <div className=\"mt-12 animate-marquee whitespace-nowrap text-black h-full w-max \">\n                  {\" \"}\n                  <div key={Math.floor(Math.random() * database.length)} className=\"text-3xl\">\n                    <span className={playerColor(character)}>\n                      {\" \"}\n                      {character?.name} <br />\n                      <span className=\"text-black\"> Lvl {character?.level} </span>\n                      {character?.race} {character.class}\n                    </span>\n\n                    <br />\n                  </div>\n                </div>\n                <div className=\"mt-16 -translate-y-1/2 animate-marquee whitespace-nowrap text-black h-full w-max \">\n                  {\" \"}\n                  <div key={Math.floor(Math.random() * database.length)} className=\"text-xl\">\n                    <span className={playerColor(character)}>\n                      {\" \"}\n                      {character?.name} <br />\n                      <span className=\"text-black\"> Lvl {character?.level} </span>\n                      {character?.race} {character.class}\n                    </span>\n                    <br />\n                  </div>\n                </div>\n                <div className=\"mt-24 animate-marquee whitespace-nowrap text-black h-full w-max \">\n                  {\" \"}\n                  <div key={Math.floor(Math.random() * database.length)} className=\"text-l\">\n                    <span className={playerColor(character)}>\n                      {\" \"}\n                      {character?.name} <br />\n                      <span className=\"text-black\"> Lvl {character?.level} </span>\n                      {character?.race} {character.class}\n                    </span>\n                  </div>\n                </div>\n                <div className=\" animate-marquee whitespace-nowrap text-black h-full w-max \">\n                  {\" \"}\n                  <div key={Math.floor(Math.random() * database.length)} className=\"text-l\">\n                    <span className={playerColor(character)}>\n                      {\" \"}\n                      {character?.name} <br />\n                      <span className=\"text-black\"> Lvl {character?.level} </span>\n                      {character?.race} {character.class}\n                    </span>\n                  </div>\n                </div>\n              </>\n            ))}\n          </div>\n        </div>\n      </div>\n      {mmToggle == true ? (\n        <div className=\"flex flex-col items-center justify-center bg-transparent text-black pt-4 -mt-16\">\n          <div style={{ zIndex: 10 }} className=\"text-center max-w-xl bg-transparent overflow-hidden rounded-md p-8\">\n            {dead && dead.length > 0 ? (\n              <Slider {...settings}>\n                {dead.map((deadCharacter, index) => (\n                  <div key={index} className=\"p-4\">\n                    {deadCharacter?.name == player?.name ? (\n                      <>\n                        <div className=\"border-2 border-gray-500 card mt-4 ml-10 mr-10 text-center text-white font-mono text-xl\">\n                          <br />\n                          <span className=\"font-bold text-2xl\">{player?.name}</span> <br />\n                          <span className=\"font-bold\">\n                            Level {player?.level} <span>{player?.race}</span>\n                            <span> {player?.class}</span>{\" \"}\n                          </span>\n                          <br />\n                          ---------------------\n                          <br />\n                          <span className=\"text-lg text-left\">\n                            {player?.equipped_items?.map((item: any) => (\n                              <div key={item.slot.type}>\n                                {item.quality.type == \"POOR\" ? (\n                                  <span className=\"text-gray-500\"> {item.name.en_US}</span>\n                                ) : (\n                                  <>\n                                    {item.quality.type == \"COMMON\" ? (\n                                      <span className=\"text-white\"> {item.name.en_US}</span>\n                                    ) : (\n                                      <>\n                                        {item.quality.type == \"UNCOMMON\" ? (\n                                          <span className=\"text-green-500\"> {item.name.en_US}</span>\n                                        ) : (\n                                          <>\n                                            {item.quality.type == \"RARE\" ? (\n                                              <span className=\"text-blue-500\"> {item.name.en_US}</span>\n                                            ) : (\n                                              <>\n                                                {item.quality.type == \"EPIC\" ? (\n                                                  <span className=\"text-purple-500\"> {item.name.en_US}</span>\n                                                ) : (\n                                                  <span className=\"text-orange-500\"> {item.name.en_US}</span>\n                                                )}\n                                              </>\n                                            )}\n                                          </>\n                                        )}\n                                      </>\n                                    )}\n                                  </>\n                                )}\n                              </div>\n                            ))}\n                          </span>\n                        </div>\n                        <br />\n                      </>\n                    ) : (\n                      <>\n                        <div className=\"card mr-3 mt-4\">\n                          <div className=\"font-mono text-xl\">\n                            In Memoriam to: <br /> {deadCharacter.name}\n                          </div>\n                          <div>\n                            <br />\n\n                            <button\n                              className=\"border-2 border-white text-center rounded-md p-2\"\n                              onClick={() => playerSelector(index)}\n                            >\n                              Memento Mori\n                            </button>\n                            <br />\n                          </div>\n                          <MyComponent index={index} />\n                        </div>\n                      </>\n                    )}\n                  </div>\n                ))}\n              </Slider>\n            ) : (\n              <div className=\"card mt-60 pr-2 z-50 font-mono\">\n                {!address ? (\n                  <RainbowKitCustomConnectButton />\n                ) : (\n                  <>\n                    {!user ? (\n                      <button\n                        className=\"border-2 border-black rounded-md\"\n                        onClick={() => {\n                          login();\n                        }}\n                      >\n                        LOGIN WITH BNET\n                      </button>\n                    ) : (\n                      <div>Logged in as {user.battletag}</div>\n                    )}\n                  </>\n                )}\n              </div>\n            )}\n\n            <br />\n          </div>\n        </div>\n      ) : (\n        <div></div>\n      )}\n      {/*login logo pulse portion and ? thing*/}\n      <div className=\"card fixed right-20 top-2/3 mt-24 pr-2 z-50 font-mono\">\n        {!address ? (\n          <RainbowKitCustomConnectButton />\n        ) : (\n          <>\n            {!user ? (\n              <button\n                className=\"border-2 border-black rounded-md\"\n                onClick={() => {\n                  login();\n                }}\n              >\n                LOGIN WITH BNET\n              </button>\n            ) : (\n              <div>Logged in as {user.battletag}</div>\n            )}\n          </>\n        )}\n\n        <div>Address: {address || \"no data\"}</div>\n        <div>User: {user ? user.battletag : \"no data\"}</div>\n        <button\n          onClick={() => {\n            logout();\n            toast.success(\"Successfully logged out\");\n          }}\n        >\n          Logout\n        </button>\n      </div>\n\n      <div\n        className=\"fixed top-2/3 left-1/2 w-1/4 h-1/3 z-50 transform -translate-x-1/2 scale-105 hover:scale-110\"\n        onClick={() => {\n          mmToggle ? setMmToggle(false) : setMmToggle(true);\n        }}\n      >\n        <Image src=\"/logo.png\" alt=\"Logo\" fill />\n      </div>\n\n      {infoToggle == true ? (\n        <div className=\"fixed z-50 border-gray-500 font-mono p-4 w-40 h-40 left-96 mr-60 top-96\">\n          <div\n            className=\"animate-bounce absolute right-20 -left-6 h-80 w-60 scale-x-110 scale-y-110\"\n            onClick={() => setInfoToggle(!infoToggle)}\n          >\n            <Image fill className=\"fixed hover:scale-110\" src=\"/question.png\" alt=\"?\" />\n          </div>\n        </div>\n      ) : (\n        <div className=\"fixed z-50 bg-black border-2  border-gray-500 font-mono p-4 w-1/2 right-60 mr-60 top-20\">\n          <span className=\"absolute right-5\" onClick={() => setInfoToggle(!infoToggle)}>\n            {\"| X |\"}{\" \"}\n          </span>\n          <span className=\"font-bold justify-center pl-96\" onClick={() => setTutoggle(!tutoggle)}>\n            üíÄ Memento Mori üíÄ\n            <br />\n            <br />\n          </span>\n          {tutoggle == true ? (\n            <>\n              Once upon a time, in a distant digital universe, countless adventurers thrived. They faced endless battles\n              and overcame numerous dangers until they each met their inevitable end. <br /> <br />\n              Just like in our reality, death is irreversible. However, the actions of these heroes leave lasting marks\n              that resonate beyond their lifespan and reverberate throughout the Multiverse.\n              <br />\n              <br />\n              <span className=\"font-bold\">üíÄ Memento Mori üíÄ</span> is an onChain memorial to fallen hardcore\n              adventurers which records their unique journey through their gear, their name, race and level at their\n              time of death and stores it for use throughout the Metaverse. Stats, images, and other functionality are\n              intentionally omitted for others to interpret. Feel free to use MementoMori in any way you want.\n              <br />\n              <br />\n              Connect with us: <br />\n              <span className=\"text-blue-500\">\n                {\" \"}\n                <a href=\"https://discord.gg/yGuUY8ZsFr\" target=\"_blank\" rel=\"noreferrer\">\n                  Discord\n                </a>\n              </span>\n              <br />\n              <span className=\"text-blue-500\">\n                {\" \"}\n                <a href=\"https://t.me/+N_-pUunbjHw3Y2Vh\" target=\"_blank\" rel=\"noreferrer\">\n                  Telegram\n                </a>\n              </span>\n              <br />\n              <span className=\"text-blue-500\">\n                {\" \"}\n                <a href=\"https://twitter.com/MMoriOnChain\" target=\"_blank\" rel=\"noreferrer\">\n                  Twitter\n                </a>\n              </span>\n              <br />\n              <span className=\"text-blue-500\">\n                {\" \"}\n                <a href=\"https://github.com/Ataxia123/MementoMori\" target=\"_blank\" rel=\"noreferrer\">\n                  Github\n                </a>\n              </span>\n              <br />\n              <br />\n              Made with {\"<3\"} by At0x.eth and the NERDS\n              <br />\n            </>\n          ) : (\n            <div className=\"p-40 text-center\">\n              <span className=\"font-bold\">\n                This project is dedicated to the memory of my dog üê∂ Tuto.\n                <br />\n              </span>\n            </div>\n          )}\n        </div>\n      )}\n    </>\n  );\n```","x":-107,"y":605,"width":409,"height":417},
		{"id":"6ce997c990dc93e9","type":"text","text":"suggest how it could be implemented given the current architecture ","x":879,"y":1472,"width":250,"height":188},
		{"id":"ab7e160116af2302","type":"text","text":"i have an issue with this display code where some of the elements are displayed badly at different resolutions, users have to change the zoom to fix it","x":-581,"y":1256,"width":250,"height":60},
		{"chat_role":"assistant","id":"f3651d214c4d7bd5","type":"text","text":"To implement the attestation mechanism integrated with the Ethereum Attestation Service (EAS) in your current application, you'll need to follow a set of steps. However, considering the vague context provided, I'll assume some general application architecture and build on that.\n\nHere's a high-level approach:\n\n1. **Define Your Schema**: As detailed in previous discussions, you need to define your AttestationData schema based on your application-specific requirements.\n\n2. **Generate Attestations**: For each event (like a character's death in Memento Mori scenario), create an AttestationData record, sign the data with an authorized entity's private key and hash the record. This will generate the attestation.\n\n3. **Construct a Merkle Tree**: Collect these attestations in batch, hash them to create the leaves of the Merkle tree, and construct the tree. The result is your Merkle root which can represent all the attestations at once.\n\n4. **Submit Merkle Root to Blockchain**: Submit the Merkle root to your Attestation smart contract on the Ethereum blockchain. This can be triggered manually or set as an automatic process scheduled at specific intervals or conditions.\n\n5. **Mint NFTs with Attestations**: When you mint your NFTs, each NFT should include a reference to its respective attestation (i.e., the leaf node hash), the Merkle root, and the proof (which is an array of hashes that allows anyone to recalculate the Merkle root using the leaf node).\n\n6. **Verification**: Now, anyone who possesses the NFT can verify its authenticity by recalculating the Merkle root using the AttestationData hash and the provided Merkle proof, and comparing it with the original Merkle root.\n\nRemember, you'll need to have a Solidity smart contract to interact with the Ethereum blockchain, and a backend (could be a web server or a serverless function) in your application to create attestations, construct the Merkle tree, and communicate with the Ethereum network. This functionality will have to be added to your existing architecture.\n\nThis is a high-level explanation, actual implementation will require careful planning, designing, and programming. It's also worth mentioning that due to the cost of gas on the Ethereum network, you may want to consider Layer-2 solutions or alternative networks if cost becomes prohibitive.","x":2231,"y":2022,"width":685,"height":1378,"color":"6"},
		{"id":"fcee9da2e99ab76d","type":"text","text":"```typescript\nimport { useEffect, useRef, useState } from \"react\";\nimport React from \"react\";\nimport Image from \"next/image\";\nimport type { NextPage } from \"next\";\nimport toast from \"react-hot-toast\";\nimport Slider from \"react-slick\";\nimport \"slick-carousel/slick/slick-theme.css\";\nimport \"slick-carousel/slick/slick.css\";\nimport { useAccount } from \"wagmi\";\nimport { RainbowKitCustomConnectButton } from \"~~/components/scaffold-eth\";\n\ntype Character = {\n  id: number;\n  name: string;\n  level: number;\n  owner: string;\n  gender: string;\n  class: string;\n  race: string;\n  faction: string;\n  is_ghost: boolean;\n  equipped_items: [unknown];\n  media?: string;\n};\n\nconst Home: NextPage = () => {\n  const [user, setUser] = useState<any>(null);\n  const [players, setPlayers] = useState<any[]>();\n  const [dead, setDead] = useState<Character[]>([]);\n  const [alive, setAlive] = useState<Character[]>([]);\n  const [database, setDatabase] = useState<any[]>([]);\n  const [player, setPlayer] = useState<Character | undefined>();\n  const [mmToggle, setMmToggle] = useState<boolean>(true);\n  const [infoToggle, setInfoToggle] = useState<boolean>(false);\n  const [tutoggle, setTutoggle] = useState<boolean>(true);\n  // Renderer\n  //\n  //\n\n  const account = useAccount();\n\n  const address = account?.address;\n  // LOGIN METHODS\n  let popup: Window | null = null;\n\n  const login = () => {\n    popup = window.open(\n      \"https://backend.nerddao.xyz/oauth/battlenet\",\n      \"targetWindow\",\n      `toolbar=no,\n       location=no,\n       status=no,\n       menubar=no,\n       scrollbars=yes,\n       resizable=yes,\n       width=620,\n       height=700`,\n    );\n    // Once the popup is closed\n    window.addEventListener(\n      \"message\",\n      event => {\n        if (event.origin !== \"https://backend.nerddao.xyz\") return;\n        console.log(\"event\", event);\n\n        if (event.data) {\n          setUser(event.data);\n          popup?.close();\n        }\n      },\n      false,\n    );\n  };\n\n  const logout = async () => {\n    try {\n      const response = await fetch(\"https://backend.nerddao.xyz/oauth/logout\", {\n        method: \"POST\",\n        credentials: \"include\",\n      });\n\n      if (response.ok) {\n        setUser(null);\n        toast.success(\"Logging out successful\");\n      } else {\n        console.error(\"Failed to logout\", response);\n        toast.error(\"Failed to logout\");\n      }\n    } catch (e) {\n      console.log(e);\n    }\n  };\n\n  const fetchDb = async () => {\n    try {\n      const response = await fetch(\"https://backend.nerddao.xyz/api/database\"); // assume the same host\n      const data = await response.json();\n      console.log(data, \"Player data from DB\");\n      setDatabase(data.players);\n    } catch (e: any) {\n      toast.error(\"error posting dead players to db\");\n      console.log(e.message);\n    }\n  };\n\n  const postDb = async (players: Character) => {\n    try {\n      const response = await fetch(\"https://backend.nerddao.xyz/api/db\", {\n        method: \"POST\",\n        credentials: \"include\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n\n        body: JSON.stringify(players),\n      });\n\n      const data = await response.json();\n      console.log(data, \"POST Player data response\");\n    } catch (e: any) {\n      toast.error(\"error posting dead players to db\");\n      console.log(e.message);\n    }\n  };\n\n  const fetchCharacter = async () => {\n    try {\n      const response = await fetch(\n        `https://us.api.blizzard.com/profile/user/wow?namespace=profile-classic1x-us&access_token=${user.token}`,\n      );\n      const data = await response.json();\n      const wowAccount = data.wow_accounts[0].characters;\n      setPlayers(wowAccount);\n    } catch (e) {\n      toast.error(\"error getting characters\");\n      console.log(e);\n    }\n  };\n\n  const fetchCharData = async (url: string) => {\n    try {\n      const response = await fetch(`${url}&access_token=${user.token}`);\n      const data = await response.json();\n\n      const index0 = alive?.findIndex(x => x.id === data.id);\n      const index1 = dead?.findIndex(x => x.id === data.id);\n      const index2 = database.findIndex(x => x.id === data._id);\n\n      const profile: Character = {\n        id: data.id,\n        name: data.name,\n        level: data.level,\n        owner: address ? address : \"no data\",\n        faction: data.faction.type,\n        race: data.race.name.en_US,\n        class: data.character_class.name.en_US,\n        gender: data.gender.type,\n        is_ghost: data.is_ghost,\n        media: data.equipment.href,\n        equipped_items: [{}],\n      };\n      console.log(data, index1, index2, \"data\");\n      if (data.is_ghost == true && index1 == -1) {\n        // maybe update database here\n        setDead(prevState => [...prevState, profile]);\n\n        return console.log(data.name, \"dead\", data.level);\n      } else {\n        if (index0 != -1 || data.level < 10) return console.log(data.name, \"already in db\", data.level);\n        console.log(profile, \"profile\");\n        setAlive(prevState => [...prevState, profile]);\n\n        return console.log(data.name, \"not dead\", data.level);\n      }\n    } catch (e) {\n      return console.log(e);\n    }\n  };\n\n  const fetchCharMedia = async (index: number) => {\n    if (!user?.token) {\n      console.log(\"No token available.\");\n      return;\n    }\n\n    try {\n      players?.forEach(character => {\n        if (character.level < 10) {\n          console.log(`${character.character.name} is too low level: ${character.character.level}`);\n          return;\n        }\n        fetchCharData(character.character.href);\n      });\n\n      // Ensure the dead array has elements and the index is valid\n      if (dead.length === 0 || index < 0 || index >= dead.length) {\n        console.log(\"Invalid index or empty dead array.\");\n        return;\n      }\n\n      const characterMedia = dead[index];\n      if (!characterMedia?.media) {\n        console.log(`No media URL found for character at index ${index}.`);\n        return;\n      }\n\n      const url = `${characterMedia.media}&access_token=${user.token}`;\n      const response = await fetch(url);\n      const data = await response.json();\n\n      const dindex = dead.findIndex(x => x.id === data.character.id);\n      if (dindex === -1) {\n        console.log(\"Character not found in dead array.\");\n        return;\n      }\n\n      setDead(prevState => {\n        const newState = [...prevState];\n        newState[dindex].equipped_items = data.equipped_items;\n        return newState;\n      });\n\n      const updatedPlayer = dead[dindex];\n      setPlayer(updatedPlayer);\n      if (updatedPlayer) {\n        postDb(updatedPlayer);\n      } else {\n        console.log(\"Player not set.\");\n      }\n    } catch (e: any) {\n      toast.error(\"Error getting equipment: \" + e.message);\n      console.log(e);\n    }\n  };\n\n  const playerSelector = async (index: number) => {\n    await fetchCharMedia(index);\n  };\n\n  useEffect(() => {\n    fetchDb();\n  }, []);\n\n  useEffect(() => {\n    if (user === null) return;\n    fetchCharacter();\n  }, [user]);\n\n  useEffect(() => {\n    console.log(players, \"players\");\n\n    players?.map((character: any) => {\n      if (character.level < 10)\n        return console.log(character.character.name, \"too low level\", character.character.level);\n      fetchCharData(character.character.href);\n    });\n\n    console.log(\"dead\", dead, \"alive\", alive);\n  }, [players]);\n\n  const settings = {\n    dots: true,\n    infinite: false,\n    speed: 500,\n    slidesToShow: 1,\n    slidesToScroll: 1,\n  };\n  // Once the popup is closed\n  //\n  const playerColor = (character: Character) => {\n    if (character.class == \"Druid\") {\n      return \"text-orange-500\";\n    } else if (character.class == \"Priest\") {\n      return \"text-gray-500\";\n    } else if (character.class == \"Warlock\") {\n      return \"text-purple-500\";\n    } else if (character.class == \"Warrior\") {\n      return \"text-brown-500\";\n    } else if (character.class == \"Paladin\") {\n      return \"text-pink-500\";\n    } else if (character.class == \"Rogue\") {\n      return \"text-yellow-500\";\n    } else if (character.class == \"Mage\") {\n      return \"text-blue-50\";\n    } else if (character.class == \"Shaman\") {\n      return \"text-blue-500\";\n    } else {\n      return \"text-green-500\";\n    }\n  };\n\n  function MyComponent(props: any) {\n    const { index } = props;\n    const componentRef = useRef(null); // Reference to the component\n\n    useEffect(() => {\n      const observer = new IntersectionObserver(entries => {\n        entries.forEach(entry => {\n          if (entry.isIntersecting) {\n            // Component is visible, add event listener\n            document.addEventListener(\"keydown\", handleKeyPress);\n          } else {\n            // Component is not visible, remove event listener\n            document.removeEventListener(\"keydown\", handleKeyPress);\n          }\n        });\n      });\n\n      const handleKeyPress = (event: any) => {\n        if (event.key === \"F\" || event.key === \"f\") {\n          playerSelector(index);\n        }\n      };\n\n      if (componentRef.current) {\n        observer.observe(componentRef.current); // Start observing\n      }\n\n      return () => {\n        if (componentRef.current) {\n          observer.unobserve(componentRef.current); // Clean up\n        }\n        document.removeEventListener(\"keydown\", handleKeyPress);\n      };\n    }, [index]);\n\n    return <div ref={componentRef}>Press F to pay Respects</div>;\n  }\n\n};\n\nexport default Home;\n\n```","x":3511,"y":1555,"width":569,"height":1479},
		{"id":"c2a179e8fc8430bf","type":"text","text":"```javascript\nimport passport from 'passport';\nimport express, { Router } from 'express';\nimport path from 'path';\nimport { MongoClient } from 'mongodb'\nimport { fileURLToPath } from 'url';\nimport https from 'https';\nimport xml2js from 'xml2js';\nconst __filename = fileURLToPath(import.meta.url);\n\nconst __dirname = path.dirname(__filename);\nconst url = process.env.MONGODB_URI;\nconst client = new MongoClient(url);\nawait client.connect();\nconsole.log('Connected successfully to server');\n// Database Name\nconst dbName = 'mementoMori';\nconst dbRouter = Router();\n\nconst useRegex = (input) => {\n  let regex = /\"displayid\":(?<displayid>[0-9]+)/i;\n  input = input.match(regex);\n  let displayid = input?.groups.displayid;\n  return displayid;\n}  //let response = result.wowhead.item[0].json[0];\ndbRouter.use(express.static(path.join(__dirname, \"../../dist/\")));\nconsole.log(__dirname);\n\n\n\ndbRouter.get('/database', async (req, res) => {\n  // Use connect method to connect to the server\n  const db = client.db(dbName); // Connect to the Database\n  const collection = db.collection('players'); // Access to 'players' collection\n  // Access to 'players' collection\n  const itemCollection = db.collection('items'); // \n\n\n  const items = await itemCollection.find({}).toArray();\n  const players = await collection.find({}).toArray();\n\n  // Get all players from collection\n  res.json({ items: items, players: players }); // Response to MongoClient\n});\n\n\ndbRouter.post('/db', async (req, res) => {\n  // Write the generated HTML to the document body\n  passport.authenticate('bnet', { failureMessage: 'Woopsie' });\n  // Parse JSON body\n\n\n\n  const db = client.db(dbName); // Connect to the database\n  const collection = db.collection('players');\n  const itemCollection = db.collection('items'); // \n\n  // assumed input\n  const inputPlayerData = req.body;\n\n  // function to save player\n  async function savePlayer(playerData) {\n    // Save only if player id does not exist\n    await collection.updateOne(\n      { id: playerData.id },\n      { $setOnInsert: playerData },\n      { upsert: true }, // this creates new document if none match the filter\n    );\n  }\n\n  // function to save item from given player\n  async function savePlayerItems(item, playerData) {\n    let itemId = item.item.id;\n    let itemInfoUrl = `https://www.wowhead.com/item=${itemId}&xml`;\n\n    let data = '';\n    const parser = new xml2js.Parser();\n    https.get(itemInfoUrl, function(res) {\n      try {\n        if (res.statusCode >= 200 && res.statusCode < 400) {\n          res.on('data', function(data_) {\n            data += data_.toString();\n\n          });\n          res.on('end', function() {\n\n            parser.parseString(data, async function(err, result) {\n              let dispid = result.wowhead.item[0].json[0];\n              let response = useRegex(dispid)\n              console.log(response)\n\n              const itemData = {\n                itemId: itemId,\n                displayId: response,\n                playerName: playerData.name,\n              };\n              return await itemCollection.updateOne(\n                { itemId: itemId },\n                { $setOnInsert: itemData },\n                { upsert: true }, // this creates new document if none match the filter\n              );\n              // Save only if item id does not exist for that player\n\n            });\n\n          })\n\n\n\n        }\n      } catch (e) {\n        parser.on('error', function(err) { console.log('Parser error', err); });\n      }\n    });\n\n\n  }\n\n  // Saving player and item\n  async function savePlayerAndItems(playerData) {\n    const playerItems = playerData.equipped_items || [];\n\n    try {\n      await savePlayer(playerData);\n      await Promise.all(playerItems.map(item => savePlayerItems(item, playerData)));\n    } catch (error) {\n      return console.error('Unable to save player data. Error:', error);\n    }\n\n    return console.log('Player data saved');\n  }\n\n  // Finally call the function with input\n  savePlayerAndItems(inputPlayerData);\n\n\n\n\n\n\n  res.json({ status: 'success', message: 'Players added to DB', body: inputPlayerData });\n\n\n\n})\n\n\n\n\n\n\n\nexport { dbRouter };\n\n\n```","x":3172,"y":3134,"width":373,"height":505},
		{"id":"d13de4eb164b497f","type":"text","text":"give me a draft for the proposed additions","x":2525,"y":3641,"width":420,"height":376},
		{"chat_role":"assistant","id":"a0f8394a58a61b12","type":"text","text":"I propose the following modifications to your current architecture for enabling the attestation mechanism using the Ethereum Attestation Service (EAS):\n\n(Note: This proposal assumes your current application architecture includes a frontend(UI), a backend API server, and a connection to the Ethereum network. Your requirements may vary.)\n\nThe following modifications consist of three key components: Backend Server (or \"Application Logic Layer\"), Ethereum Smart Contracts, and Frontend.\n\n## Backend Server (Application Logic Layer)\n\n1. **Attestation Creation Module**: Implement a module to create and sign the attestations off-chain. This will handle creating an AttestationData record whenever a relevant event occurs (like a character's death). The data will be signed with an authorized entity's private key.\n\n2. **Merkle Tree Constructor**: This module will gather the signed attestations in batches and construct a Merkle tree. It will then identify the Merkle root.\n\n3. **NFT Minting Manager**: It will be responsible for triggering the minting process on your Ethereum smart contracts. During minting, it will include the necessary data (Merkle root, proof, etc.).\n\n## Ethereum Smart Contracts\n\n1. **Attestation Contract Modifications**: Modify the existing smart contract to accept and store the Merkle root related to each NFT drop. This contract will also emit an event for each NFT minting, marking the new owner and the link (hash of the attestation) to the verified off-chain data.\n\n2. **NFT Minting Contract Modifications**: Modify the minting function to require additional parameters (Merkle root, proof, etc.). Also, it will be modified to link the NFT to its respective attestation.\n\n## Frontend (User Interface)\n\n1. **Attestation Data Viewer**: A function or a separate page to fetch and view the attestation data of an NFT.\n\n2. **Public Verification Feature**: Implement a feature allowing anyone to verify the authenticity of the NFT's attestation by using the frontend's connection to the Ethereum network to compare the recorded Merkle root and the recalculated root from the NFT's data and proof.\n\nPlease note, the technical requirements will vary according to the specifics of your architecture. This proposal serves as a general guideline and may need further adjustment based on your current setup. Be sure to address any data security and privacy concerns, particularly for off-chain data, and conduct thorough testing before deploying live to ensure system integrity and user security.","x":2127,"y":4200,"width":1162,"height":1059,"color":"6"}
	],
	"edges":[
		{"id":"7336d5dd3c4a0fd4","fromNode":"Proofs of Knowledge/Study Questions/New Questions/202311141423.md","fromSide":"right","toNode":"af0b4c2b1a58b070","toSide":"left"},
		{"id":"d64864e6997f13f1","fromNode":"Proofs of Knowledge/Study Questions/New Questions/202311141423.md","fromSide":"right","toNode":"67b0c5c2b9c64f8c","toSide":"left"},
		{"id":"a5c2c05074e8825a","fromNode":"978e6a1c32e34788","fromSide":"bottom","toNode":"90a24c77a9b132d6","toSide":"top"},
		{"id":"9f53c7595f5ba133","fromNode":"67b0c5c2b9c64f8c","fromSide":"right","toNode":"90a24c77a9b132d6","toSide":"top"},
		{"id":"6f6c62d0ea63a890","fromNode":"af0b4c2b1a58b070","fromSide":"right","toNode":"90a24c77a9b132d6","toSide":"top"},
		{"id":"500635dac6431cc4","fromNode":"90a24c77a9b132d6","fromSide":"bottom","toNode":"0a8ff82caaac40a9","toSide":"top"},
		{"id":"78c011d55aa883d4","fromNode":"90a24c77a9b132d6","fromSide":"bottom","toNode":"f26c139fa4164532","toSide":"top"},
		{"id":"4e643780834c83af","fromNode":"90a24c77a9b132d6","fromSide":"bottom","toNode":"a417d417ac1f8ee7","toSide":"top"},
		{"id":"865fae64d6cf1588","fromNode":"f26c139fa4164532","fromSide":"right","toNode":"336dc328d6e26549","toSide":"top"},
		{"id":"0db65ef03c1052ab","fromNode":"336dc328d6e26549","fromSide":"bottom","toNode":"3eca90d6674a22d2","toSide":"top"},
		{"id":"2f26adab46130ecf","fromNode":"3eca90d6674a22d2","fromSide":"right","toNode":"85e876fabf8c608e","toSide":"left"},
		{"id":"e5b675fb2f85686c","fromNode":"85e876fabf8c608e","fromSide":"bottom","toNode":"3f1fe987678ed549","toSide":"top"},
		{"id":"bae845cc0e4c369c","fromNode":"3f1fe987678ed549","fromSide":"right","toNode":"cdc50170fe26b2bc","toSide":"left"},
		{"id":"51294f3bf05d7f72","fromNode":"cdc50170fe26b2bc","fromSide":"bottom","toNode":"749e9db9eb109db2","toSide":"top"},
		{"id":"62be7d5b34e56f28","fromNode":"749e9db9eb109db2","fromSide":"right","toNode":"b4f06a79a75cb737","toSide":"top"},
		{"id":"b92674c8cf295a1b","fromNode":"fcee9da2e99ab76d","fromSide":"bottom","toNode":"b4f06a79a75cb737","toSide":"top"},
		{"id":"e034fa1df2bbd10f","fromNode":"9bc042f5a1121982","fromSide":"bottom","toNode":"b4f06a79a75cb737","toSide":"top"},
		{"id":"bc71240bb2b88dde","fromNode":"b4f06a79a75cb737","fromSide":"bottom","toNode":"d9acb1f5ad1201d7","toSide":"top"},
		{"id":"5694ea88d7fdc42e","fromNode":"d9acb1f5ad1201d7","fromSide":"right","toNode":"197d6f5fb901c150","toSide":"left"},
		{"id":"4e252d9ee1759bb6","fromNode":"238ffa58444174db","fromSide":"left","toNode":"197d6f5fb901c150","toSide":"right"},
		{"id":"97d974f73bdcc4cc","fromNode":"11d88c52bd0e80cb","fromSide":"left","toNode":"551c2fb977ca9fd3","toSide":"right"},
		{"id":"c32b848cebfaeaea","fromNode":"551c2fb977ca9fd3","fromSide":"left","toNode":"197d6f5fb901c150","toSide":"right"},
		{"id":"d1fe5580cd93f36f","fromNode":"197d6f5fb901c150","fromSide":"bottom","toNode":"2ebce47ed2acac41","toSide":"top"},
		{"id":"1df7387114743337","fromNode":"c2a179e8fc8430bf","fromSide":"bottom","toNode":"b4f06a79a75cb737","toSide":"top"},
		{"id":"d07697a8515f3770","fromNode":"b4f06a79a75cb737","fromSide":"right","toNode":"6ce997c990dc93e9","toSide":"left"},
		{"id":"a70fcc57f34597a0","fromNode":"6ce997c990dc93e9","fromSide":"bottom","toNode":"f3651d214c4d7bd5","toSide":"top"},
		{"id":"112d6cb5ddb3989d","fromNode":"9bc042f5a1121982","fromSide":"left","toNode":"ab7e160116af2302","toSide":"right"},
		{"id":"3abd96bbada4fe3c","fromNode":"ab7e160116af2302","fromSide":"bottom","toNode":"904e6ce4ebcaf63b","toSide":"top"},
		{"id":"3b4883e778763003","fromNode":"f3651d214c4d7bd5","fromSide":"bottom","toNode":"d13de4eb164b497f","toSide":"top"},
		{"id":"7f24dc3a70c15628","fromNode":"c2a179e8fc8430bf","fromSide":"left","toNode":"d13de4eb164b497f","toSide":"top"},
		{"id":"506bdbffab539e86","fromNode":"fcee9da2e99ab76d","fromSide":"left","toNode":"d13de4eb164b497f","toSide":"top"},
		{"id":"1b5cf5e0d821a8d5","fromNode":"d13de4eb164b497f","fromSide":"bottom","toNode":"a0f8394a58a61b12","toSide":"top"}
	]
}