{
	"nodes":[
		{"id":"8f40a42034fe64df","type":"group","x":-2298,"y":-1846,"width":2218,"height":3286,"label":"Untitled group"},
		{"id":"855f1a7fcfbd979e","type":"text","text":"# TABLE LIBRARIES\n\nMethods on [`StoreCore`](https://mud.dev/references/store-core) and [`IStore`](https://mud.dev/references/store) use raw bytes as input and output types. This is to allow using the same methods for different types of tables types without native support for generics in Solidity, but it can be inconvenient to work with. For this reason MUD automatically generates a library for each table that provides typed methods corresponding to the table's key and value types.\n\n## CONFIG[](https://mud.dev/store/table-libraries#config)\n\nTable libraries are generated by the [`tablegen`](https://mud.dev/cli/tablegen) CLI. The [CLI config](https://mud.dev/cli/config) section goes into more detail on the available configuration options.\n\nTo illustrate table library functionality on this page, we'll use two example tables with the following configurations:\n\nPosition\n\n```\nschema: {  entity: \"address\",   // Two static length fields  x: \"uint32\",  y: \"uint32\",},key: [\"entity\"],\n```\n\nInventory\n\n```\nschema: {  entity: \"address\",   // One dynamic length field  slots: \"uint8[]\",},key: [\"entity\"],\n```\n\n### SINGLETON TABLES[](https://mud.dev/store/table-libraries#singleton-tables)\n\nWhen you just need to store a single value (for example, the world map or the name of an in-game currency), you use a singleton table, a table whose key schema is empty. With an empty key schema there is just one record.\n\nCounter\n\n```\nschema: {  value: \"uint32\",},key: [],\n```\n\n## USAGE[](https://mud.dev/store/table-libraries#usage)\n\n### IMPORTING THE LIBRARY[](https://mud.dev/store/table-libraries#importing-the-library)\n\nBy default table libraries are generated into a `codegen/tables` directory in the contract directory. This can be configured with the `codegenDirectory` option in the [config](https://mud.dev/cli/config). The library name corresponds to the table's key in the table config.\n\n```\nimport { Position } from \"./codegen/tables/Position.sol\";import { Inventory } from \"./codegen/tables/Inventory.sol\";\n```\n\nFor convenience, the [`tablegen`](https://mud.dev/cli/tablegen) CLI also generates an `index.sol` file that re-exports all the generated table libraries.\n\n```\nimport { Position, Inventory } from \"./codegen/tables/index.sol\";\n```\n\n### REGISTERING THE TABLE[](https://mud.dev/store/table-libraries#registering-the-table)\n\nBefore using the table library, it must be registered once in the Store. This happens automatically as part of the [deploy CLI](https://mud.dev/cli/deploy), but if you're using the table library in a [Module](https://mud.dev/world/modules) or a contract that's not deployed by MUD, you'll need to register it manually.\n\n```\nPosition.register();Inventory.register();\n```\n\nThe table library will detect the `Store` context automatically (via [`StoreSwitch`](https://mud.dev/store/table-libraries#storeswitch)).\n\n### READING DATA[](https://mud.dev/store/table-libraries#reading-data)\n\nTable libraries provide typed methods for reading data from the `Store`.\n\n#### READ FULL RECORD[](https://mud.dev/store/table-libraries#read-full-record)\n\nTo read the entire record, use the `get` method. If the table's value schema contains more than one field, the method returns a struct with the corresponding fields.\n\n```\nimport { Position, PositionData } from \"./codegen/tables/Position.sol\"; address entity = address(0x1234);PositionData memory position = Position.get(entity);\n```\n\n#### READ INDIVIDUAL FIELDS[](https://mud.dev/store/table-libraries#read-individual-fields)\n\nTo read a single field, use the `get` method with the field name as a suffix.\n\n```\nimport { Position } from \"./codegen/tables/Position.sol\"; address entity = address(0x1234);uint32 x = Position.getX(entity);\n```\n\n#### READ LENGTH OF DYNAMIC LENGTH FIELD[](https://mud.dev/store/table-libraries#read-length-of-dynamic-length-field)\n\nTo read the length of a dynamic length field, use the `length` method with the field name as a suffix.\n\n```\nimport { Inventory } from \"./codegen/tables/Inventory.sol\"; address entity = address(0x1234);uint256 length = Inventory.lengthSlots(entity);\n```\n\n#### READ INDIVIDUAL ELEMENTS OF DYNAMIC LENGTH FIELD[](https://mud.dev/store/table-libraries#read-individual-elements-of-dynamic-length-field)\n\nTo read individual fields of a dynamic length field, use the `getItem` method with the field name as a suffix and the index as an argument.\n\n```\nimport { Inventory } from \"./codegen/tables/Inventory.sol\"; address entity = address(0x1234);uint8 item = Inventory.getItemSlots(entity, 0);\n```\n\n### WRITING DATA[](https://mud.dev/store/table-libraries#writing-data)\n\nTable libraries provide typed methods for writing data to the `Store`.\n\n#### WRITE FULL RECORD[](https://mud.dev/store/table-libraries#write-full-record)\n\nTo write the entire record, use the `set` method. There is a variant of this method that accepts a struct, and a variant that accepts the individual fields.\n\n```\nimport { Position, PositionData } from \"./codegen/tables/Position.sol\"; address entity = address(0x1234); // set with individual fieldsPosition.set(entity, 1, 2); // or set with structPosition.set(entity, PositionData(1,2));\n```\n\n#### WRITE INDIVIDUAL FIELDS[](https://mud.dev/store/table-libraries#write-individual-fields)\n\nTo write a single field, use the `set` method with the field name as a suffix.\n\n```\nimport { Position } from \"./codegen/tables/Position.sol\"; address entity = address(0x1234);Position.setX(entity, 1);\n```\n\n#### WRITE INDIVIDUAL ELEMENTS OF DYNAMIC LENGTH FIELD[](https://mud.dev/store/table-libraries#write-individual-elements-of-dynamic-length-field)\n\nTo write individual fields of a dynamic length field, use the `update` method with the field name as a suffix and the index as an argument.\n\n```\nimport { Inventory } from \"./codegen/tables/Inventory.sol\"; address entity = address(0x1234);Inventory.updateSlots(entity, 0, 1);\n```\n\n#### PUSH TO DYNAMIC LENGTH FIELD[](https://mud.dev/store/table-libraries#push-to-dynamic-length-field)\n\nTo push a new element to a dynamic length field, use the `push` method with the field name as a suffix.\n\n```\nimport { Inventory } from \"./codegen/tables/Inventory.sol\"; address entity = address(0x1234);Inventory.pushSlots(entity, 1);\n```\n\n#### POP FROM DYNAMIC LENGTH FIELD[](https://mud.dev/store/table-libraries#pop-from-dynamic-length-field)\n\nTo remove the last element from a dynamic length field, use the `pop` method with the field name as a suffix.\n\n```\nimport { Inventory } from \"./codegen/tables/Inventory.sol\"; address entity = address(0x1234);Inventory.popSlots(entity);\n```\n\nNote that this method does not return the popped element. If you need to access the popped element, use the `getItem` method before calling `pop`.\n\n```\nimport { Inventory } from \"./codegen/tables/Inventory.sol\"; address entity = address(0x1234);uint256 length = Inventory.lengthSlots(entity);uint8 lastItem = Inventory.getItemSlots(entity,  length - 1);Inventory.popSlots(entity);\n```\n\n## ADVANCED[](https://mud.dev/store/table-libraries#advanced)\n\n### STORESWITCH[](https://mud.dev/store/table-libraries#storeswitch)\n\nTable libraries internally use the `StoreSwitch` library to write data to the Store. `StoreSwitch` detects whether the library is called from within a `Store` contract or from an external contract that has a reference to the `Store` contract.\n\n1. If the library is called from within a `Store` contract, `StoreSwitch` accesses the store directly via the [internal `StoreCore` library](https://mud.dev/store/reference/store-core).\n2. If the library is called from a contract that has a fixed reference to a specific external `Store` contract, `StoreSwitch` accesses this `Store` via the [external `IStore` interface](https://mud.dev/store/reference/store).\n3. If `msg.sender` is a `Store` contract, `StoreSwitch` accesses the `Store` via the caller's address via the [external `IStore` interface](https://mud.dev/store/reference/store).\n\nTo fix a reference to a specific `Store` contract (2), use the `StoreSwitch.setStoreAddress` method in your contract.\n\n```\nimport { StoreSwitch } from \"@latticexyz/store/src/StoreSwitch.sol\"; StoreSwitch.setStoreAddress(STORE_ADDRESS);\n```\n\nThis can be useful to test libraries using table libraries in isolation, by setting the `Store` address in the test contract to a mock `Store` contract. This happens automatically in the [`MudTest`](https://mud.dev/cli/test) setup.","x":-2200,"y":-1760,"width":307,"height":429,"color":"6"},
		{"id":"b3f0de196305c8f3","type":"text","text":"# TABLES\n\nEach piece of data in `Store` is stored as a _record_ in a _table_. You can think of tables in two ways, either [as a relational database](https://mud.dev/store/data-model) or as a key-value store.\n\n- Each table is identified by a unique `ResourceId tableId`.\n- Each record in a table is identified by a unique `bytes32[] keyTuple`. You can think of the key tuple as a composite key in a relational database, or as a nested mapping in a key-value store.\n- Each table has a value schema (all the `schema` fields that aren't part of the `key`) that defines the types of data stored in the table. You can think of the value schema as the column types in a table in a relational database, or the type of structs stored in a key-value store.\n\nTables are registered in the `Store` contract at runtime. When a table is registered, its ID, key and value types, as well as key and field names are stored in the internal `Tables` table. This emits an event that can be used by [offchain indexers](https://mud.dev/services/indexer) to start [replicating the state](https://mud.dev/guides/replicating-onchain-state) of the new table.\n\nThe recommended way of reading from tables and writing to tables is via the [typed table libraries](https://mud.dev/store/table-libraries). However, it is also possible to use the low-level [`IStore` (external)](https://mud.dev/store/reference/store) or [`StoreCore` (internal)](https://mud.dev/store/reference/store-core) API directly.\n\n⚠️\n\nOnce a table is created its schema is _immutable_. If you need to add fields to an existing table, create a new table with the same key schema and the new fields in the value schema, and retrieve from both tables to get the complete value. If you need to delete fields, just have your code ignore them.\n\n## TYPES OF TABLES[](https://mud.dev/store/tables#types-of-tables)\n\nThere are two types of tables in `Store`: _Onchain tables_ and _offchain tables_. We often omit the prefix from onchain tables and just call them tables.\n\nAs the name suggests, **onchain tables** store their state onchain, in the `Store` contract. In addition, an event is emitted on every write operation, to allow [offchain indexers](https://mud.dev/services/indexer) to [replicate the onchain state](https://mud.dev/guides/replicating-onchain-state).\n\n**Offchain tables** on the other hand don't store any state onchain, but only emit the events for [offchain indexers](https://mud.dev/services/indexer). This makes them suitable for use cases where data doesn't need to be retrieved onchain, but should still be synchronized from the `Store` contract to [offchain indexers](https://mud.dev/services/indexer).\n\nOnchain you can write to offchain tables with the same methods as onchain tables, except for reading data and modifying partial data in a dynamic field.","x":-1868,"y":-1760,"width":321,"height":429,"color":"6"},
		{"id":"acd837cb2c39d9c3","type":"text","text":"Creating tables for a boss monster battle in MUD involves defining schemas that hold relevant data for the battle. This could include information about the boss monster, players involved, battle status, actions being taken, and so forth. Below is an example configuration for these tables.\n\n### Boss Table\n\nThis table will store information about the boss monster, such as its stats and current state in the battle.\n\n```\nschema: {\n  id: \"uint256\",\n  name: \"string\",\n  health: \"uint256\",\n  maxHealth: \"uint256\",\n  attackPower: \"uint256\",\n  defense: \"uint256\",\n},\nkey: [\"id\"],\n```\n\n### Player Table\n\nThis table will store information about players involved in the battle, such as their stats, health, and position in the battle.\n\n```\nschema: {\n  address: \"address\",\n  name: \"string\",\n  health: \"uint256\",\n  maxHealth: \"uint256\",\n  attackPower: \"uint256\",\n  defense: \"uint256\",\n},\nkey: [\"address\"],\n```\n\n### Battle Status Table\n\nThis table tracks the status of the battle, including which players are involved and the current phase of the battle.\n\n```\nschema: {\n  bossId: \"uint256\",\n  phase: \"string\",\n  players: \"address[]\",\n  turnOrder: \"address[]\",\n},\nkey: [\"bossId\"],\n```\n\n### Player Actions Table\n\nThis table records each player's actions in the battle.\n\n```\nschema: {\n  entity: \"address\",\n  actionType: \"string\", // e.g., \"attack\", \"defend\", \"item\"\n  target: \"uint256\",   // Could be player or boss ID, depending on actionType\n  timestamp: \"uint256\",\n},\nkey: [\"entity\", \"timestamp\"],\n```\n\n### Singleton Table for Battle Configuration\n\nThis table stores global configuration for the battle, like the maximum number of players or various multipliers.\n\n```\nschema: {\n  maxPlayers: \"uint256\",\n  attackMultiplier: \"uint256\",\n  defenseMultiplier: \"uint256\",\n  timeLimit: \"uint256\",\n},\nkey: [],\n```\n\n## Usage Examples\n\n### Importing the Libraries\n\nFirst, you need to import the generated libraries for the tables.\n\n```solidity\nimport { Boss } from \"./codegen/tables/Boss.sol\";\nimport { Player } from \"./codegen/tables/Player.sol\";\nimport { BattleStatus } from \"./codegen/tables/BattleStatus.sol\";\nimport { PlayerActions } from \"./codegen/tables/PlayerActions.sol\";\nimport { BattleConfig } from \"./codegen/tables/BattleConfig.sol\";\n```\n\nFor convenience, you can use the generated `index.sol` to import all tables at once:\n\n```solidity\nimport { Boss, Player, BattleStatus, PlayerActions, BattleConfig } from \"./codegen/tables/index.sol\";\n```\n\n### Registering the Tables\n\nEnsure that each table is registered before use by calling the `register` method. If you're deploying through MUD, this step may already be handled.\n\n```solidity\nBoss.register();\nPlayer.register();\nBattleStatus.register();\nPlayerActions.register();\nBattleConfig.register();\n```\n\n### Example of Setting Up a Boss\n\n```solidity\nuint256 bossId = 1;\nBoss.set(\n  bossId,\n  \"Dragon of Doom\",\n  10000,  // health\n  10000,  // maxHealth\n  200,    // attackPower\n  100     // defense\n);\n```\n\n### Example of Adding a Player\n\n```solidity\naddress playerAddr = address(0x1234);\nPlayer.set(\n  playerAddr,\n  \"Knight\",\n  1000,  // health\n  1000,  // maxHealth\n  150,   // attackPower\n  80     // defense\n);\n```\n\n### Example of Updating Battle Status\n\n```solidity\nuint256 bossId = 1;\naddress[] memory players = new address[](1);\nplayers[0] = address(0x1234);\naddress[] memory turnOrder = new address[](1);\nturnOrder[0] = address(0x1234);\n\nBattleStatus.set(\n  bossId,\n  \"INITIAL_PHASE\", // phase\n  players,         // players\n  turnOrder        // turnOrder\n);\n```\n\n### Example of Recording an Action\n\n```solidity\naddress playerAddr = address(0x1234);\nuint256 timestamp = block.timestamp;\n\nPlayerActions.set(\n  playerAddr,\n  \"attack\",\n  1,         // Targeting the boss with ID 1\n  timestamp\n);\n```\n\n### Example of Configuring Battle\n\n```solidity\nBattleConfig.set(\n  4,    // maxPlayers\n  100,  // attackMultiplier\n  50,   // defenseMultiplier\n  300   // timeLimit in seconds\n);\n```\n\nBy defining these tables, you can effectively manage and track various aspects of the boss monster battle, including the boss's stats, players' information, battle status, and actions taken during the battle.","x":-2120,"y":-640,"width":695,"height":1552,"color":"6"},
		{"id":"acb07a67fe5ca776","type":"text","text":"# Current mud.config.ts\n```ts\nimport { defineWorld } from \"@latticexyz/world\";\n\n// Define enums for better type safety and readability\nconst EntityType = [\"Player\"];\n\nexport default defineWorld({\n  enums: {\n    EntityType,\n  },\n  tables: {\n    Player: {\n      schema: {\n        id: \"bytes32\",\n        x: \"int32\",\n        y: \"int32\",\n        health: \"uint32\",\n        name: \"string\",\n      },\n      key: [\"id\"],\n    },\n    Lore: {\n      schema: {\n        id: \"bytes32\",\n        alignment: \"string\",\n        backstory: \"string\",\n        currentQuest: \"string\",\n      },\n      key: [\"id\"],\n    },\n    Inventory: {\n      schema: {\n        ownerId: \"bytes32\",\n        itemIds: \"uint8[]\", // Changed to bytes32[] for dynamic length\n      },\n      key: [\"ownerId\"],\n    },\n    Item: {\n      schema: {\n        itemId: \"bytes8\", // Changed to bytes32 for a more consistent key type\n        itemCount: \"uint256\",\n        itemName: \"string\",\n      },\n      key: [\"itemId\"],\n    },\n  },\n  deploy: {\n    upgradeableWorldImplementation: true,\n  },\n});\n```\n","x":-1718,"y":-1240,"width":368,"height":480,"color":"3"},
		{"id":"9cf2240d4adad5da","type":"text","text":"Below is the updated `mud.config.ts` file, which includes the tables for a boss monster battle as discussed:\n\n```ts\nimport { defineWorld } from \"@latticexyz/world\";\n\n// Define enums for better type safety and readability\nconst EntityType = [\"Player\", \"Boss\"];\n\nexport default defineWorld({\n  enums: {\n    EntityType,\n  },\n  tables: {\n    Player: {\n      schema: {\n        id: \"bytes32\",\n        x: \"int32\",\n        y: \"int32\",\n        health: \"uint32\",\n        maxHealth: \"uint32\",\n        attackPower: \"uint32\",\n        defense: \"uint32\",\n        name: \"string\",\n      },\n      key: [\"id\"],\n    },\n    Lore: {\n      schema: {\n        id: \"bytes32\",\n        alignment: \"string\",\n        backstory: \"string\",\n        currentQuest: \"string\",\n      },\n      key: [\"id\"],\n    },\n    Inventory: {\n      schema: {\n        ownerId: \"bytes32\",\n        itemIds: \"bytes32[]\", // Changed to bytes32[] for dynamic length\n      },\n      key: [\"ownerId\"],\n    },\n    Item: {\n      schema: {\n        itemId: \"bytes32\", // Changed to bytes32 for a more consistent key type\n        itemCount: \"uint256\",\n        itemName: \"string\",\n      },\n      key: [\"itemId\"],\n    },\n    Boss: {\n      schema: {\n        id: \"bytes32\",\n        name: \"string\",\n        health: \"uint256\",\n        maxHealth: \"uint256\",\n        attackPower: \"uint256\",\n        defense: \"uint256\",\n      },\n      key: [\"id\"],\n    },\n    BattleStatus: {\n      schema: {\n        bossId: \"bytes32\",\n        phase: \"string\",\n        players: \"bytes32[]\",     // List of player IDs\n        turnOrder: \"bytes32[]\",   // Order of player IDs for turns\n      },\n      key: [\"bossId\"],\n    },\n    PlayerActions: {\n      schema: {\n        entity: \"bytes32\",\n        actionType: \"string\", // e.g., \"attack\", \"defend\", \"item\"\n        target: \"bytes32\",    // Could be player or boss ID, depending on actionType\n        timestamp: \"uint256\",\n      },\n      key: [\"entity\", \"timestamp\"],\n    },\n    BattleConfig: {\n      schema: {\n        maxPlayers: \"uint256\",\n        attackMultiplier: \"uint256\",\n        defenseMultiplier: \"uint256\",\n        timeLimit: \"uint256\",\n      },\n      key: [], // Singleton table\n    },\n  },\n  deploy: {\n    upgradeableWorldImplementation: true,\n  },\n});\n```\n\n### Explanation:\n\n- **Player Table**: Added the `maxHealth`, `attackPower`, and `defense` fields for combat stats.\n- **Boss Table**: Added a table to store information about the boss, including its health, attack power, and defense.\n- **BattleStatus Table**: This new table keeps track of players involved in the battle, the current phase of the battle, and the turn order.\n- **PlayerActions Table**: This new table records each player's actions, including action type, target, and timestamp.\n- **BattleConfig Table**: A singleton table that stores global configuration settings for the battle, such as maximum players, attack multipliers, defense multipliers, and time limits.\n\nApply this configuration, and you'll be able to track and manage a boss monster battle along with your existing player, lore, inventory, and item tables.","x":-1280,"y":-1502,"width":880,"height":1882,"color":"6"},
		{"id":"8a14e06e456373e1","type":"text","text":"Create tables for a boss monster battle","x":-2160,"y":-1130,"width":351,"height":260,"color":"4"},
		{"id":"cfdb92b92c39180e","type":"text","text":"Based on your notes, here is an action plan for implementing new features using the framework described in your [[CodeReport]]:\n### Action Plan for New Features\n#### 1. **Feature: Enhanced Inventory Management**\n- **Objective:** Improve the inventory system to support item categorization, stackable items, and inventory limits.\n- **Steps:**\n1. **Define New Schemas:**\n- Update `mud.config.ts` to include new fields for item categories and stack limits.\n```typescript\nInventory: {\nschema: {\nownerId: \"bytes32\",\nitems: \"Item[]\",\nmaxCapacity: \"uint256\",\n},\nkey: [\"ownerId\"],\n},\nItem: {\nschema: {\nitemId: \"uint256\",\nitemCount: \"uint256\",\nitemName: \"string\",\ncategory: \"string\",\nstackLimit: \"uint256\",\n},\nkey: [\"itemId\"],\n},\n```\n2. **Update Solidity Contract:**\n- Modify `InventorySystem.sol` to handle item stacking and enforce inventory limits.\n```solidity\nfunction addItemToInventory(bytes32 ownerId, uint256 itemId, uint256 count) public {\nInventoryData memory inventory = Inventory.get(ownerId);\n// Check if the item already exists and stack it\nuint256 index = findIndex(inventory.items, itemId);\nif (index < inventory.items.length) {\nrequire(inventory.items[index].itemCount + count <= inventory.items[index].stackLimit, \"Exceeds stack limit\");\ninventory.items[index].itemCount += count;\n} else {\nrequire(inventory.items.length < inventory.maxCapacity, \"Inventory full\");\ninventory.items.push(Item({itemId: itemId, itemCount: count, itemName: \"\", category: \"\", stackLimit: 0}));\n}\nInventory.set(ownerId, inventory);\n}\n```\n3. **Implement Client-Side Logic:**\n- Update the client-side code to handle new inventory features, such as displaying item categories and stack counts.\n#### 2. **Feature: Player Trading System**\n- **Objective:** Enable players to trade items with each other.\n- **Steps:**\n1. **Define New Schemas:**\n- Add a new table for trade offers in `mud.config.ts`.\n```typescript\nTradeOffer: {\nschema: {\nofferId: \"bytes32\",\nfromPlayer: \"bytes32\",\ntoPlayer: \"bytes32\",\nofferedItems: \"Item[]\",\nrequestedItems: \"Item[]\",\nstatus: \"string\", // \"pending\", \"accepted\", \"rejected\"\n},\nkey: [\"offerId\"],\n},\n```\n2. **Create Trade System Contract:**\n- Implement a new contract `TradeSystem.sol` to handle trade offers.\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport { System } from \"@latticexyz/world/src/System.sol\";\nimport { TradeOffer, TradeOfferData, Inventory, InventoryData } from \"../codegen/index.sol\";\nimport { addressToEntityKey } from \"../addressToEntityKey.sol\";\ncontract TradeSystem is System {\nfunction createTradeOffer(bytes32 toPlayer, Item[] memory offeredItems, Item[] memory requestedItems) public {\nbytes32 fromPlayer = addressToEntityKey(_msgSender());\nbytes32 offerId = keccak256(abi.encodePacked(fromPlayer, toPlayer, block.timestamp));\nTradeOffer.set(offerId, TradeOfferData({\nofferId: offerId,\nfromPlayer: fromPlayer,\ntoPlayer: toPlayer,\nofferedItems: offeredItems,\nrequestedItems: requestedItems,\nstatus: \"pending\"\n}));\n}\nfunction acceptTradeOffer(bytes32 offerId) public {\nTradeOfferData memory offer = TradeOffer.get(offerId);\nrequire(offer.toPlayer == addressToEntityKey(_msgSender()), \"Not the recipient\");\nrequire(keccak256(abi.encodePacked(offer.status)) == keccak256(\"pending\"), \"Offer not pending\");\n// Transfer items between players\n// Update inventories and offer status\noffer.status = \"accepted\";\nTradeOffer.set(offerId, offer);\n}\nfunction rejectTradeOffer(bytes32 offerId) public {\nTradeOfferData memory offer = TradeOffer.get(offerId);\nrequire(offer.toPlayer == addressToEntityKey(_msgSender()), \"Not the recipient\");\nrequire(keccak256(abi.encodePacked(offer.status)) == keccak256(\"pending\"), \"Offer not pending\");\noffer.status = \"rejected\";\nTradeOffer.set(offerId, offer);\n}\n}\n```\n3. **Implement Client-Side Logic:**\n- Add UI components for creating, viewing, and managing trade offers.\n- Ensure that the client-side code interacts correctly with the `TradeSystem` contract.\n#### 3. **Feature: Dynamic Quests System**\n- **Objective:** Introduce a dynamic quests system where players can receive and complete quests.\n- **Steps:**\n1. **Define New Schemas:**\n- Add tables for quests and player quest progress in `mud.config.ts`.\n```typescript\nQuest: {\nschema: {\nquestId: \"bytes32\",\ntitle: \"string\",\ndescription: \"string\",\nreward: \"Item[]\",\nstatus: \"string\", // \"available\", \"completed\"\n},\nkey: [\"questId\"],\n},\nPlayerQuest: {\nschema: {\nplayerId: \"bytes32\",\nquestId: \"bytes32\",\nprogress: \"uint256\",\nstatus: \"string\", // \"in-progress\", \"completed\"\n},\nkey: [\"playerId\", \"questId\"],\n},\n```\n2. **Create Quest System Contract:**\n- Implement a new contract `QuestSystem.sol` to manage quests.\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport { System } from \"@latticexyz/world/src/System.sol\";\nimport { Quest, QuestData, PlayerQuest, PlayerQuestData, Inventory, InventoryData } from \"../codegen/index.sol\";\nimport { addressToEntityKey } from \"../addressToEntityKey.sol\";\ncontract QuestSystem is System {\nfunction startQuest(bytes32 questId) public {\nbytes32 playerId = addressToEntityKey(_msgSender());\nPlayerQuest.set(playerId, questId, PlayerQuestData({\nplayerId: playerId,\nquestId: questId,\nprogress: 0,\nstatus: \"in-progress\"\n}));\n}\nfunction completeQuest(bytes32 questId) public {\nbytes32 playerId = addressToEntityKey(_msgSender());\nPlayerQuestData memory playerQuest = PlayerQuest.get(playerId, questId);\nrequire(keccak256(abi.encodePacked(playerQuest.status)) == keccak256(\"in-progress\"), \"Quest not in progress\");\n// Update player quest progress and status\nplayerQuest.status = \"completed\";\nPlayerQuest.set(playerId, questId, playerQuest);\n// Grant rewards to player\nQuestData memory quest = Quest.get(questId);\nInventoryData memory inventory = Inventory.get(playerId);\nfor (uint i = 0; i < quest.reward.length; i++) {\ninventory.items.push(quest.reward[i]);\n}\nInventory.set(playerId, inventory);\n}\n}\n```\n3. **Implement Client-Side Logic:**\n- Add UI components for displaying available quests, tracking quest progress, and claiming rewards.\n- Ensure that the client-side code interacts correctly with the `QuestSystem` contract.\n### Summary\nBy following this action plan, you will be able to implement enhanced inventory management, a player trading system, and a dynamic quests system using the framework described in your notes. Each feature involves updating the schema definitions, implementing new or modified Solidity contracts, and adding corresponding client-side logic to ensure a seamless user experience.","x":-520,"y":-1802,"width":400,"height":600,"color":"6"}
	],
	"edges":[
		{"id":"34f33ddb852fa626","fromNode":"b3f0de196305c8f3","fromSide":"bottom","toNode":"8a14e06e456373e1","toSide":"top"},
		{"id":"afc592544053d0ec","fromNode":"855f1a7fcfbd979e","fromSide":"bottom","toNode":"8a14e06e456373e1","toSide":"top"},
		{"id":"912997d39bf2115c","fromNode":"8a14e06e456373e1","fromSide":"bottom","toNode":"acd837cb2c39d9c3","toSide":"top"},
		{"id":"6d05531a9a5373bd","fromNode":"8a14e06e456373e1","fromSide":"right","toNode":"acb07a67fe5ca776","toSide":"left"},
		{"id":"ceea10221f027bdb","fromNode":"acb07a67fe5ca776","fromSide":"right","toNode":"9cf2240d4adad5da","toSide":"top"}
	]
}