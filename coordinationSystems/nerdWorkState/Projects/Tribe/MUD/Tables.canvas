{
	"nodes":[
		{"id":"8f40a42034fe64df","type":"group","x":-2298,"y":-1846,"width":4596,"height":3693,"label":"Untitled group"},
		{"id":"abbc7fd92f8536f0","type":"text","text":"# Tables\n\n`World` uses the [store tables](/store/tables), but adds [access control](/world/namespaces-access-control). For onchain tables, the data is stored by the `World` contract, [which is also a `StoreData` (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/world/src/World.sol#L43).\n\nWhen a `System` reads or writes storage via [table libraries](/store/table-libraries), the request goes into [`StoreSwitch` (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/store/src/StoreSwitch.sol). This library decides which approach to use:\n\n- If the `System` is in the root namespace, then it was called with [`delegatecall` (opens in a new tab)](https://docs.soliditylang.org/en/v0.8.22/introduction-to-smart-contracts.html#delegatecall-and-libraries). This means it inherits the `World` storage and can write directly to storage using [`StoreCore` (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/store/src/StoreCore.sol). These calls bypass access control.\n    \n- If the `System` is in any other namespace, then it was called with [`call` (opens in a new tab)](https://docs.soliditylang.org/en/v0.8.22/introduction-to-smart-contracts.html#message-calls) and has to call back into the `World` using [`IStore` (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/store/src/IStore.sol). These calls go through access control. They are only permitted if the `System` has access to the table in question. By default a `System` has access to its own namespace and therefore to all the tables inside it. Additional [access can be granted](/world/namespaces-access-control) by the namespace owner.\n    \n\n![Interaction between the World, a System, and a table](https://mud.dev/world/tables/_next/static/media/world-table.39df342f.svg)\n\n1. An account calls a function called `game__myFunc` on the `World`. [This function was registered](/world/function-selectors) by the owner of the `game` namespace and points to the `myFunc` function in one of the `System`s in the `namespace` namespace.\n    \n2. The `World` verifies that access is permitted (for example, because `game:System` is publicly accessible) and if so calls `myFunc` on the `game:System` contract with the provided parameters.\n    \n3. At some point in its execution `myFunc` decides to update the data in the table `game:Items`. As with all other tables, this table is stored in the `World`'s storage. To modify it, `function` calls a function on the `World` contract.\n    \n4. The `World` verifies that access is permitted (by default it would be, because `game:System` has access to the `game` namespace). If so, it modifies the data in the `game:Items` table.\n    \n\nâš ï¸\n\nOnce a table is created its schema is _immutable_. If you need to add fields to an existing table, create a new table with the same key schema and the new fields in the value schema, and retrieve from both tables to get the complete value. If you need to delete fields, just have your code ignore them.\n\n## Code samples[](#code-samples)\n\n### Reading from a table[](#reading-from-a-table)\n\nAnybody connected to the blockchain can run the `view` functions that read table content, provided they know which key to use (by default MUD does not keep a list of keys written to a table onchain, to save on storage operations).\n\nAll the functions to [read from a MUD store](/store/table-libraries#reading-data) are available. In this example we use the `Counter` table in the [vanilla](/templates/typescript/vanilla) template, which is a singleton so there is no key to worry about.\n\nReadCounter.s.sol\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n \nimport { Script } from \"forge-std/Script.sol\";\nimport { console } from \"forge-std/console.sol\";\nimport { StoreSwitch } from \"@latticexyz/store/src/StoreSwitch.sol\";\nimport { Counter } from \"../src/codegen/index.sol\";\n \ncontract ReadCounter is Script {\n  function run() external {\n    address worldAddress = 0xC14fBdb7808D9e2a37c1a45b635C8C3fF64a1cc1;\n    StoreSwitch.setStoreAddress(worldAddress);\n    console.log(\"Counter value:\", Counter.get());\n  }\n}\n```\n\nExplanation\n\n```\nimport { StoreSwitch } from \"@latticexyz/store/src/StoreSwitch.sol\";\n```\n\nWe need [the `StoreSwitch` library (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/store/src/StoreSwitch.sol) library to specify the address of the `World` with the data.\n\n```\nimport { Counter } from \"../src/codegen/index.sol\";\n```\n\nIt is easiest if we import the definitions of the table that were generated using [`mud tablegen`](/cli/tablegen).\n\n```\n    address worldAddress = 0xC14fBdb7808D9e2a37c1a45b635C8C3fF64a1cc1;\n    StoreSwitch.setStoreAddress(worldAddress);\n```\n\nUse [`StoreSwitch` (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/store/src/StoreSwitch.sol) with the `World` address.\n\n```\n    console.log(\"Counter value:\", Counter.get());\n```\n\nRead the information. If this had been a table with a key, we'd need to provide the key as a parameter to `<table name>.get()`.\n\n### Writing to table[](#writing-to-table)\n\nAll the functions to [write to a MUD store](/store/table-libraries#writing-data) are available. In this example we reset `Counter` to zero. Note that only [authorized addresses](/world/namespaces-access-control#access) are allowed to write directly to a table.\n\nResetCounter.s.sol\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n \nimport { Script } from \"forge-std/Script.sol\";\nimport { console } from \"forge-std/console.sol\";\nimport { StoreSwitch } from \"@latticexyz/store/src/StoreSwitch.sol\";\nimport { Counter } from \"../src/codegen/index.sol\";\n \ncontract ResetCounter is Script {\n  function run() external {\n    // Specify a store so that you can use tables directly\n    address worldAddress = 0xC14fBdb7808D9e2a37c1a45b635C8C3fF64a1cc1;\n    StoreSwitch.setStoreAddress(worldAddress);\n \n    // Load the private key from the `PRIVATE_KEY` environment variable (in .env)\n    uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\");\n \n    // Start broadcasting transactions from the deployer account\n    vm.startBroadcast(deployerPrivateKey);\n    Counter.set(0);\n    vm.stopBroadcast();\n \n    console.log(\"Counter value:\", Counter.get());\n  }\n}\n```\n\nExplanation\n\n```\n    Counter.set(0);\n```\n\nThis is how you modify a table's value. If there was a key, it would be `<table name>.set(<key fields>,<value fields>)`.\n","x":-2278,"y":-1662,"width":617,"height":799},
		{"id":"24e15be5d0f047e9","type":"text","text":"```ts\nimport { getNetworkConfig } from \"./getNetworkConfig\";\nimport { world } from \"./world\";\nimport { ContractWrite, createBurnerAccount, transportObserver } from \"@latticexyz/common\";\nimport { transactionQueue, writeObserver } from \"@latticexyz/common/actions\";\nimport { createFaucetService } from \"@latticexyz/services/faucet\";\nimport { encodeEntity, syncToRecs } from \"@latticexyz/store-sync/recs\";\nimport { syncToZustand } from \"@latticexyz/store-sync/zustand\";\nimport mudConfig from \"contracts/mud.config\";\nimport IWorldAbi from \"contracts/out/IWorld.sol/IWorld.abi.json\";\nimport { Subject, share } from \"rxjs\";\nimport {\n  ClientConfig,\n  Hex,\n  createPublicClient,\n  createWalletClient,\n  fallback,\n  getContract,\n  http,\n  parseEther,\n  webSocket,\n} from \"viem\";\n\nexport type SetupNetworkResult = Awaited<ReturnType<typeof setupNetwork>>;\nexport async function setupNetwork() {\n  const networkConfig = await getNetworkConfig();\n  const clientOptions = {\n    chain: networkConfig.chain,\n    transport: transportObserver(fallback([webSocket(), http()])),\n    pollingInterval: 1000,\n  } as const satisfies ClientConfig;\n  const publicClient = createPublicClient(clientOptions);\n  const write$ = new Subject<ContractWrite>();\n  const burnerAccount = createBurnerAccount(networkConfig.privateKey as Hex);\n  const burnerWalletClient = createWalletClient({\n    ...clientOptions,\n    account: burnerAccount,\n  })\n    .extend(transactionQueue())\n    .extend(writeObserver({ onWrite: write => write$.next(write) }));\n  const worldContract = getContract({\n    address: networkConfig.worldAddress as Hex,\n    abi: IWorldAbi,\n    client: { public: publicClient, wallet: burnerWalletClient },\n  });\n  const { components, latestBlock$, storedBlockLogs$, waitForTransaction } = await syncToRecs({\n    world,\n    config: mudConfig,\n    address: networkConfig.worldAddress as Hex,\n    publicClient,\n    startBlock: BigInt(networkConfig.initialBlockNumber),\n  });\n  const { tables, useStore } = await syncToZustand({\n    config: mudConfig,\n    address: networkConfig.worldAddress as Hex,\n    publicClient,\n    startBlock: BigInt(networkConfig.initialBlockNumber),\n  });\n  if (networkConfig.faucetServiceUrl) {\n    const address = burnerAccount.address;\n    console.info(\"[Dev Faucet]: Player address -> \", address);\n    const faucet = createFaucetService(networkConfig.faucetServiceUrl);\n    const requestDrip = async () => {\n      const balance = await publicClient.getBalance({ address });\n      console.info(`[Dev Faucet]: Player balance -> ${balance}`);\n      const lowBalance = balance < parseEther(\"1\");\n      if (lowBalance) {\n        console.info(\"[Dev Faucet]: Balance is low, dripping funds to player\");\n        await faucet.dripDev({ address });\n        await faucet.dripDev({ address });\n      }\n    };\n    requestDrip();\n    setInterval(requestDrip, 20000);\n  }\n  return {\n    tables,\n    useStore,\n    world,\n    components,\n    playerEntity: encodeEntity({ address: \"address\" }, { address: burnerWalletClient.account.address }),\n    publicClient,\n    walletClient: burnerWalletClient,\n    latestBlock$,\n    storedBlockLogs$,\n    waitForTransaction,\n    worldContract,\n    write$: write$.asObservable().pipe(share()),\n  };\n}\n\n```","x":-2079,"y":-1567,"width":553,"height":1020},
		{"id":"2c364a653dc937c6","type":"text","text":"Creating a new table for the game inventory involves updating both your Solidity smart contracts and the MUD configuration files. Here's a step-by-step guide to create a new table called `game:Inventory` which will store information about the items that players have in their inventory.\n\n### Step 1: Define the Table in MUD Configuration\n\nFirst, you need to define your new table in the MUD configuration file, typically a YAML file that lists all your tables. Let's assume your configuration file is named `tables.yaml` and you're adding a new table definition for `Inventory`.\n\nExample `tables.yaml`:\n\n```yaml\ntables:\n  Inventory:\n    namespace: game\n    keySchema:\n      playerAddress: address\n      itemId: uint256\n    valueSchema:\n      itemName: string\n      itemCount: uint256\n```\n\nThis configuration sets up the table in the `game` namespace with `playerAddress` and `itemId` as keys, and `itemName` and `itemCount` as values.\n\n### Step 2: Generate Solidity Code\n\nRun the MUD code generation tool to create the necessary Solidity code to work with your new table.\n\n```sh\nmud tablegen\n```\n\nThis will generate the necessary Solidity files for the `Inventory` table, typically placing them in the `src/codegen/` directory.\n\n### Step 3: Update Smart Contract to Use the Inventory Table\n\nNow, let's create a new Solidity script to interact with the `game:Inventory` table. This script will demonstrate reading from and writing to the `Inventory` table.\n\nCreate a new file called `ManageInventory.s.sol`:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n\nimport { Script } from \"forge-std/Script.sol\";\nimport { console } from \"forge-std/console.sol\";\nimport { StoreSwitch } from \"@latticexyz/store/src/StoreSwitch.sol\";\nimport { Inventory, InventoryData } from \"../src/codegen/index.sol\";\n\ncontract ManageInventory is Script {\n    function run() external {\n        address worldAddress = 0xC14fBdb7808D9e2a37c1a45b635C8C3fF64a1cc1;\n        StoreSwitch.setStoreAddress(worldAddress);\n\n        // Example player address and item details\n        address playerAddress = 0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC;\n        uint256 itemId = 1;\n        string memory itemName = \"Sword\";\n        uint256 itemCount = 10;\n\n        // Load the private key from the `PRIVATE_KEY` environment variable (in .env)\n        uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\");\n\n        // Start broadcasting transactions from the deployer account\n        vm.startBroadcast(deployerPrivateKey);\n\n        // Add item to inventory\n        Inventory.set(playerAddress, itemId, InventoryData({\n            itemName: itemName,\n            itemCount: itemCount\n        }));\n\n        vm.stopBroadcast();\n\n        // Read the inventory\n        InventoryData memory data = Inventory.get(playerAddress, itemId);\n        console.log(\"Item Name:\", data.itemName);\n        console.log(\"Item Count:\", data.itemCount);\n    }\n}\n```\n\nIn the above script:\n- We set the store address to the `World` contract's address.\n- We use the `set` method to add an item to the inventory.\n- We use the `get` method to fetch the inventory details.\n\n### Step 4: Deploy and Test\n\nFinally, you need to deploy your updated contracts and run the script to interact with the `Inventory` table.\n\n```sh\nforge script ManageInventory.s.sol --rpc-url YOUR_RPC_URL --broadcast --private-key YOUR_PRIVATE_KEY\n```\n\n### Explanation of the Script\n\n```solidity\naddress playerAddress = 0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC;\nuint256 itemId = 1;\nstring memory itemName = \"Sword\";\nuint256 itemCount = 10;\n```\n\nSet up the example details for a player who has 10 \"Sword\" items.\n\n```solidity\nInventory.set(playerAddress, itemId, InventoryData({\n    itemName: itemName,\n    itemCount: itemCount\n}));\n```\n\nAdd these details to the `Inventory` table.\n\n```solidity\nInventoryData memory data = Inventory.get(playerAddress, itemId);\nconsole.log(\"Item Name:\", data.itemName);\nconsole.log(\"Item Count:\", data.itemCount);\n```\n\nFetch and print the details from the `Inventory` table.\n\nThis script sets the foundation for interacting with the `game:Inventory` table in your Solidity smart contracts using MUD.","x":-2079,"y":-1662,"width":729,"height":877},
		{"id":"fb6ebfbe6be8411e","type":"text","text":"Create a new Table for the game inventory","x":-1714,"y":-1329,"width":342,"height":272},
		{"id":"855f1a7fcfbd979e","type":"text","text":"# TABLE LIBRARIES\n\nMethods onÂ [`StoreCore`](https://mud.dev/references/store-core)Â andÂ [`IStore`](https://mud.dev/references/store)Â use raw bytes as input and output types. This is to allow using the same methods for different types of tables types without native support for generics in Solidity, but it can be inconvenient to work with. For this reason MUD automatically generates a library for each table that provides typed methods corresponding to the table's key and value types.\n\n## CONFIG[](https://mud.dev/store/table-libraries#config)\n\nTable libraries are generated by theÂ [`tablegen`](https://mud.dev/cli/tablegen)Â CLI. TheÂ [CLI config](https://mud.dev/cli/config)Â section goes into more detail on the available configuration options.\n\nTo illustrate table library functionality on this page, we'll use two example tables with the following configurations:\n\nPosition\n\n```\nschema: {  entity: \"address\",   // Two static length fields  x: \"uint32\",  y: \"uint32\",},key: [\"entity\"],\n```\n\nInventory\n\n```\nschema: {  entity: \"address\",   // One dynamic length field  slots: \"uint8[]\",},key: [\"entity\"],\n```\n\n### SINGLETON TABLES[](https://mud.dev/store/table-libraries#singleton-tables)\n\nWhen you just need to store a single value (for example, the world map or the name of an in-game currency), you use a singleton table, a table whose key schema is empty. With an empty key schema there is just one record.\n\nCounter\n\n```\nschema: {  value: \"uint32\",},key: [],\n```\n\n## USAGE[](https://mud.dev/store/table-libraries#usage)\n\n### IMPORTING THE LIBRARY[](https://mud.dev/store/table-libraries#importing-the-library)\n\nBy default table libraries are generated into aÂ `codegen/tables`Â directory in the contract directory. This can be configured with theÂ `codegenDirectory`Â option in theÂ [config](https://mud.dev/cli/config). The library name corresponds to the table's key in the table config.\n\n```\nimport { Position } from \"./codegen/tables/Position.sol\";import { Inventory } from \"./codegen/tables/Inventory.sol\";\n```\n\nFor convenience, theÂ [`tablegen`](https://mud.dev/cli/tablegen)Â CLI also generates anÂ `index.sol`Â file that re-exports all the generated table libraries.\n\n```\nimport { Position, Inventory } from \"./codegen/tables/index.sol\";\n```\n\n### REGISTERING THE TABLE[](https://mud.dev/store/table-libraries#registering-the-table)\n\nBefore using the table library, it must be registered once in the Store. This happens automatically as part of theÂ [deploy CLI](https://mud.dev/cli/deploy), but if you're using the table library in aÂ [Module](https://mud.dev/world/modules)Â or a contract that's not deployed by MUD, you'll need to register it manually.\n\n```\nPosition.register();Inventory.register();\n```\n\nThe table library will detect theÂ `Store`Â context automatically (viaÂ [`StoreSwitch`](https://mud.dev/store/table-libraries#storeswitch)).\n\n### READING DATA[](https://mud.dev/store/table-libraries#reading-data)\n\nTable libraries provide typed methods for reading data from theÂ `Store`.\n\n#### READ FULL RECORD[](https://mud.dev/store/table-libraries#read-full-record)\n\nTo read the entire record, use theÂ `get`Â method. If the table's value schema contains more than one field, the method returns a struct with the corresponding fields.\n\n```\nimport { Position, PositionData } from \"./codegen/tables/Position.sol\"; address entity = address(0x1234);PositionData memory position = Position.get(entity);\n```\n\n#### READ INDIVIDUAL FIELDS[](https://mud.dev/store/table-libraries#read-individual-fields)\n\nTo read a single field, use theÂ `get`Â method with the field name as a suffix.\n\n```\nimport { Position } from \"./codegen/tables/Position.sol\"; address entity = address(0x1234);uint32 x = Position.getX(entity);\n```\n\n#### READ LENGTH OF DYNAMIC LENGTH FIELD[](https://mud.dev/store/table-libraries#read-length-of-dynamic-length-field)\n\nTo read the length of a dynamic length field, use theÂ `length`Â method with the field name as a suffix.\n\n```\nimport { Inventory } from \"./codegen/tables/Inventory.sol\"; address entity = address(0x1234);uint256 length = Inventory.lengthSlots(entity);\n```\n\n#### READ INDIVIDUAL ELEMENTS OF DYNAMIC LENGTH FIELD[](https://mud.dev/store/table-libraries#read-individual-elements-of-dynamic-length-field)\n\nTo read individual fields of a dynamic length field, use theÂ `getItem`Â method with the field name as a suffix and the index as an argument.\n\n```\nimport { Inventory } from \"./codegen/tables/Inventory.sol\"; address entity = address(0x1234);uint8 item = Inventory.getItemSlots(entity, 0);\n```\n\n### WRITING DATA[](https://mud.dev/store/table-libraries#writing-data)\n\nTable libraries provide typed methods for writing data to theÂ `Store`.\n\n#### WRITE FULL RECORD[](https://mud.dev/store/table-libraries#write-full-record)\n\nTo write the entire record, use theÂ `set`Â method. There is a variant of this method that accepts a struct, and a variant that accepts the individual fields.\n\n```\nimport { Position, PositionData } from \"./codegen/tables/Position.sol\"; address entity = address(0x1234); // set with individual fieldsPosition.set(entity, 1, 2); // or set with structPosition.set(entity, PositionData(1,2));\n```\n\n#### WRITE INDIVIDUAL FIELDS[](https://mud.dev/store/table-libraries#write-individual-fields)\n\nTo write a single field, use theÂ `set`Â method with the field name as a suffix.\n\n```\nimport { Position } from \"./codegen/tables/Position.sol\"; address entity = address(0x1234);Position.setX(entity, 1);\n```\n\n#### WRITE INDIVIDUAL ELEMENTS OF DYNAMIC LENGTH FIELD[](https://mud.dev/store/table-libraries#write-individual-elements-of-dynamic-length-field)\n\nTo write individual fields of a dynamic length field, use theÂ `update`Â method with the field name as a suffix and the index as an argument.\n\n```\nimport { Inventory } from \"./codegen/tables/Inventory.sol\"; address entity = address(0x1234);Inventory.updateSlots(entity, 0, 1);\n```\n\n#### PUSH TO DYNAMIC LENGTH FIELD[](https://mud.dev/store/table-libraries#push-to-dynamic-length-field)\n\nTo push a new element to a dynamic length field, use theÂ `push`Â method with the field name as a suffix.\n\n```\nimport { Inventory } from \"./codegen/tables/Inventory.sol\"; address entity = address(0x1234);Inventory.pushSlots(entity, 1);\n```\n\n#### POP FROM DYNAMIC LENGTH FIELD[](https://mud.dev/store/table-libraries#pop-from-dynamic-length-field)\n\nTo remove the last element from a dynamic length field, use theÂ `pop`Â method with the field name as a suffix.\n\n```\nimport { Inventory } from \"./codegen/tables/Inventory.sol\"; address entity = address(0x1234);Inventory.popSlots(entity);\n```\n\nNote that this method does not return the popped element. If you need to access the popped element, use theÂ `getItem`Â method before callingÂ `pop`.\n\n```\nimport { Inventory } from \"./codegen/tables/Inventory.sol\"; address entity = address(0x1234);uint256 length = Inventory.lengthSlots(entity);uint8 lastItem = Inventory.getItemSlots(entity,  length - 1);Inventory.popSlots(entity);\n```\n\n## ADVANCED[](https://mud.dev/store/table-libraries#advanced)\n\n### STORESWITCH[](https://mud.dev/store/table-libraries#storeswitch)\n\nTable libraries internally use theÂ `StoreSwitch`Â library to write data to the Store.Â `StoreSwitch`Â detects whether the library is called from within aÂ `Store`Â contract or from an external contract that has a reference to theÂ `Store`Â contract.\n\n1. If the library is called from within aÂ `Store`Â contract,Â `StoreSwitch`Â accesses the store directly via theÂ [internalÂ `StoreCore`Â library](https://mud.dev/store/reference/store-core).\n2. If the library is called from a contract that has a fixed reference to a specific externalÂ `Store`Â contract,Â `StoreSwitch`Â accesses thisÂ `Store`Â via theÂ [externalÂ `IStore`Â interface](https://mud.dev/store/reference/store).\n3. IfÂ `msg.sender`Â is aÂ `Store`Â contract,Â `StoreSwitch`Â accesses theÂ `Store`Â via the caller's address via theÂ [externalÂ `IStore`Â interface](https://mud.dev/store/reference/store).\n\nTo fix a reference to a specificÂ `Store`Â contract (2), use theÂ `StoreSwitch.setStoreAddress`Â method in your contract.\n\n```\nimport { StoreSwitch } from \"@latticexyz/store/src/StoreSwitch.sol\"; StoreSwitch.setStoreAddress(STORE_ADDRESS);\n```\n\nThis can be useful to test libraries using table libraries in isolation, by setting theÂ `Store`Â address in the test contract to a mockÂ `Store`Â contract. This happens automatically in theÂ [`MudTest`](https://mud.dev/cli/test)Â setup.","x":-2232,"y":-423,"width":307,"height":429},
		{"id":"8a14e06e456373e1","type":"text","text":"Review and refactor the Item and Inventory tables using the reference of the library using dynamic length entries","x":-1836,"y":-423,"width":351,"height":260},
		{"id":"b3f0de196305c8f3","type":"text","text":"# TABLES\n\nEach piece of data inÂ `Store`Â is stored as aÂ _record_Â in aÂ _table_. You can think of tables in two ways, eitherÂ [as a relational database](https://mud.dev/store/data-model)Â or as a key-value store.\n\n- Each table is identified by a uniqueÂ `ResourceId tableId`.\n- Each record in a table is identified by a uniqueÂ `bytes32[] keyTuple`. You can think of the key tuple as a composite key in a relational database, or as a nested mapping in a key-value store.\n- Each table has a value schema (all theÂ `schema`Â fields that aren't part of theÂ `key`) that defines the types of data stored in the table. You can think of the value schema as the column types in a table in a relational database, or the type of structs stored in a key-value store.\n\nTables are registered in theÂ `Store`Â contract at runtime. When a table is registered, its ID, key and value types, as well as key and field names are stored in the internalÂ `Tables`Â table. This emits an event that can be used byÂ [offchain indexers](https://mud.dev/services/indexer)Â to startÂ [replicating the state](https://mud.dev/guides/replicating-onchain-state)Â of the new table.\n\nThe recommended way of reading from tables and writing to tables is via theÂ [typed table libraries](https://mud.dev/store/table-libraries). However, it is also possible to use the low-levelÂ [`IStore`Â (external)](https://mud.dev/store/reference/store)Â orÂ [`StoreCore`Â (internal)](https://mud.dev/store/reference/store-core)Â API directly.\n\nâš ï¸\n\nOnce a table is created its schema isÂ _immutable_. If you need to add fields to an existing table, create a new table with the same key schema and the new fields in the value schema, and retrieve from both tables to get the complete value. If you need to delete fields, just have your code ignore them.\n\n## TYPES OF TABLES[](https://mud.dev/store/tables#types-of-tables)\n\nThere are two types of tables inÂ `Store`:Â _Onchain tables_Â andÂ _offchain tables_. We often omit the prefix from onchain tables and just call them tables.\n\nAs the name suggests,Â **onchain tables**Â store their state onchain, in theÂ `Store`Â contract. In addition, an event is emitted on every write operation, to allowÂ [offchain indexers](https://mud.dev/services/indexer)Â toÂ [replicate the onchain state](https://mud.dev/guides/replicating-onchain-state).\n\n**Offchain tables**Â on the other hand don't store any state onchain, but only emit the events forÂ [offchain indexers](https://mud.dev/services/indexer). This makes them suitable for use cases where data doesn't need to be retrieved onchain, but should still be synchronized from theÂ `Store`Â contract toÂ [offchain indexers](https://mud.dev/services/indexer).\n\nOnchain you can write to offchain tables with the same methods as onchain tables, except for reading data and modifying partial data in a dynamic field.","x":-2035,"y":-501,"width":299,"height":586},
		{"id":"ea639d2dad2e5541","type":"text","text":"```ts\nimport React, { useState } from \"react\";\nimport { useMUD } from \"./mud/MUDContext\";\nimport { usePlayerStore } from \"~~/services/store/playerStore\";\n\nconst PlayerInput = () => {\n  const playerName = usePlayerStore(state => state.playerName);\n  const setPlayerName = usePlayerStore(state => state.setPlayerName);\n  const { lore, setLore } = usePlayerStore();\n\n  const {\n    systemCalls: { spawn },\n  } = useMUD();\n\n  return (\n    <div className=\"p-2 form-control\">\n      <h2 className=\"mb-5 text-2xl font-bold text-gray-800\">Edit Lore:</h2>\n      <div>\n        <label className=\"label\">Player Name</label>\n        <input\n          className=\"input\"\n          type=\"text\"\n          value={playerName}\n          onChange={e => setPlayerName(e.target.value)}\n          placeholder=\"Enter player name\"\n        />\n      </div>\n      <div>\n        <label className=\"label\">Alignment:</label>\n        <input\n          className=\"input\"\n          value={lore.alignment}\n          onChange={e => setLore({ ...lore, alignment: e.target.value })}\n        />\n      </div>\n      <div>\n        <label className=\"label\">Backstory:</label>\n        <textarea\n          className=\"input\"\n          value={lore.backstory}\n          onChange={e => setLore({ ...lore, backstory: e.target.value })}\n        />\n      </div>\n      <div>\n        <label className=\"label\">Current Quest:</label>\n        <input\n          className=\"input\"\n          value={lore.currentQuest}\n          onChange={e => setLore({ ...lore, currentQuest: e.target.value })}\n        />\n      </div>\n\n      <button className=\"btn\" onClick={spawn}>\n        spawn\n      </button>\n    </div>\n  );\n};\n\nexport default PlayerInput;\n```","x":1585,"y":21,"width":430,"height":460,"color":"6"},
		{"id":"36dd2d2be3827888","type":"text","text":"```ts\nimport React from \"react\";\nimport { useMUD } from \"./mud/MUDContext\";\n\nconst LoreDisplay = ({ entityId }) => {\n  const {\n    network: { playerEntity, useStore, tables },\n  } = useMUD();\n\n  const lore = useStore(state => Object.values(state.getRecords(tables.Lore)));\n  console.log(\"All Lore:\", lore); // Log all lore objects\n  console.log(\"Entity ID:\", entityId); // Log the entityId being searched for\n\n  const myLore = lore.find(item => item.key.id === entityId);\n  console.log(\"Found Lore:\", myLore); // Log the found lore object\n\n  if (!myLore) return <div>No lore available for this entity.</div>;\n\n  return (\n    <div className=\"p-5 bg-gray-100 rounded-lg shadow-md\">\n      <h2 className=\"mb-5 text-2xl font-bold text-gray-800\">Lore:</h2>\n      <p>\n        <strong>Alignment:</strong> {myLore.value.alignment}\n      </p>\n      <p>\n        <strong>Backstory:</strong> {myLore.value.backstory}\n      </p>\n      <p>\n        <strong>Current Quest:</strong> {myLore.value.currentQuest}\n      </p>\n    </div>\n  );\n};\n```","x":1585,"y":293,"width":687,"height":577,"color":"6"},
		{"id":"9994f30f9c46fdce","type":"text","text":"```ts\nimport { defineWorld } from \"@latticexyz/world\";\n\n// Define enums for better type safety and readability\nconst EntityType = [\"Player\"];\n\nexport default defineWorld({\n  enums: {\n    EntityType,\n  },\n  tables: {\n    Player: {\n      schema: {\n        id: \"bytes32\",\n        x: \"int32\",\n        y: \"int32\",\n        health: \"uint32\",\n        name: \"string\",\n      },\n      key: [\"id\"],\n    },\n    Lore: {\n      schema: {\n        id: \"bytes32\",\n        alignment: \"string\",\n        backstory: \"string\",\n        currentQuest: \"string\",\n      },\n      key: [\"id\"],\n    },\n  },\n  deploy: {\n    upgradeableWorldImplementation: true,\n  },\n});\n\n```","x":-1609,"y":-1746,"width":834,"height":807},
		{"id":"ef1c5c10dfce25f6","type":"text","text":"Update the interface to handle the new calls","x":705,"y":21,"width":282,"height":272,"color":"4"},
		{"id":"fdb701df9e5053a6","type":"text","text":"Review  the system that manages the Inventory make sure there's a cohesive orchestration between systems","x":-1285,"y":-458,"width":449,"height":313,"color":"4"},
		{"id":"e40614becf9e9231","type":"text","text":"Update postDeployScript to set up a player with inventory","x":-561,"y":-529,"width":335,"height":142,"color":"4"},
		{"id":"ac01609e1754f004","type":"text","text":"```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { System } from \"@latticexyz/world/src/System.sol\";\nimport { Inventory, Item, ItemData } from \"../codegen/index.sol\";\nimport { addressToEntityKey } from \"../addressToEntityKey.sol\";\n\ncontract InventorySystem is System {\n    function addItemToInventory(bytes32 ownerId, bytes32 itemId, uint256 itemCount, string calldata itemName) public {\n        // Ensure the item does not already exist\n        ItemData memory existingItem = Item.get(itemId);\n        require(existingItem.itemId == bytes32(0), \"Item already exists\");\n\n        // Create the item\n        Item.set(itemId, ItemData({ itemId: itemId, itemCount: itemCount, itemName: itemName }));\n\n        // Get the inventory item IDs of the owner\n        bytes32[] memory currentInventory = Inventory.get(ownerId);\n\n        // Add the new item to the inventory\n        bytes32[] memory newInventory = new bytes32[](currentInventory.length + 1);\n        for (uint256 i = 0; i < currentInventory.length; i++) {\n            newInventory[i] = currentInventory[i];\n        }\n        newInventory[currentInventory.length] = itemId;\n\n        // Update the inventory\n        Inventory.set(ownerId, newInventory);\n    }\n\n    function removeItemFromInventory(bytes32 ownerId, bytes32 itemId) public {\n        // Get the inventory item IDs of the owner\n        bytes32[] memory currentInventory = Inventory.get(ownerId);\n\n        // Find the index of the item to remove\n        uint256 indexToRemove = currentInventory.length;\n        for (uint256 i = 0; i < currentInventory.length; i++) {\n            if (currentInventory[i] == itemId) {\n                indexToRemove = i;\n                break;\n            }\n        }\n\n        require(indexToRemove < currentInventory.length, \"Item not found in inventory\");\n\n        // Create a new array without the item to remove\n        bytes32[] memory newInventory = new bytes32[](currentInventory.length - 1);\n        for (uint256 i = 0; i < currentInventory.length - 1; i++) {\n            if (i < indexToRemove) {\n                newInventory[i] = currentInventory[i];\n            } else {\n                newInventory[i] = currentInventory[i + 1];\n            }\n        }\n\n        // Update the inventory\n        Inventory.set(ownerId, newInventory);\n\n        // Remove the item from the Item table\n        Item.remove(itemId);\n    }\n\n    function getInventoryItems(bytes32 ownerId) public view returns (ItemData[] memory) {\n        // Get the inventory item IDs of the owner\n        bytes32[] memory currentInventory = Inventory.get(ownerId);\n\n        // Gather item details\n        ItemData[] memory items = new ItemData[](currentInventory.length);\n        for (uint256 i = 0; i < currentInventory.length; i++) {\n            items[i] = Item.get(currentInventory[i]);\n        }\n\n        return items;\n    }\n}\n```","x":-1235,"y":-1596,"width":504,"height":746,"color":"6"},
		{"id":"b9e3dd1da8ddf496","type":"text","text":"\n\n# Systems\n\nOne of the design principles of MUD is to separate the state of the `World` from the business logic. The business logic is implemented in stateless `System` contracts. `System`s are called through the `World`, and call back to the `World` to read and write state from [tables](/world/tables).\n\nDetailed illustration\n\n![Interaction between the World, a System, and a table](https://mud.dev/world/systems/_next/static/media/world-table.39df342f.svg)\n\n1. An account calls a function called `game__myFunc` on the `World`. [This function was registered](/world/function-selectors) by the owner of the `game` namespace and points to the `myFunc` function in one of the `System`s in the `namespace` namespace.\n    \n2. The `World` verifies that access is permitted (for example, because `game:System` is publicly accessible) and if so calls `myFunc` on the `game:System` contract with the provided parameters.\n    \n3. At some point in its execution `myFunc` decides to update the data in the table `game:Items`. As with all other tables, this table is stored in the `World`'s storage. To modify it, `function` calls a function on the `World` contract.\n    \n4. The `World` verifies that access is permitted (by default it would be, because `game:System` has access to the `game` namespace). If so, it modifies the data in the `game:Items` table.\n    \n\nThe `World` serves as a central entry point and forwards calls to systems, which allows it to provide [access control](/world/namespaces-access-control).\n\n## Calling systems[](#calling-systems)\n\nTo call a `System`, you call the `World` in one of these ways:\n\n- If a [function selector for the `System` is registered in the `World`](/world/function-selectors), you can call it via `world.<namespace>__<function>(<arguments>)`.\n- You can use [`call` (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/world/src/World.sol#L333-L345).\n- If you have [the proper delegation](/world/account-delegation) you can use [`callFrom` (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/world/src/World.sol#L347-L388).\n\n### Using `call`[](#using-call)\n\nTo use `call` you create the calldata to send the called `System` and use that as a parameter.\n\nCall.s.sol\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n \nimport { Script } from \"forge-std/Script.sol\";\nimport { console } from \"forge-std/console.sol\";\nimport { StoreSwitch } from \"@latticexyz/store/src/StoreSwitch.sol\";\n \nimport { IWorld } from \"../src/codegen/world/IWorld.sol\";\nimport { Tasks, TasksData } from \"../src/codegen/index.sol\";\n \nimport { ResourceId, WorldResourceIdLib, WorldResourceIdInstance } from \"@latticexyz/world/src/WorldResourceId.sol\";\nimport { RESOURCE_SYSTEM } from \"@latticexyz/world/src/worldResourceTypes.sol\";\n \ncontract Call is Script {\n  function run() external {\n    address worldAddress = 0xC14fBdb7808D9e2a37c1a45b635C8C3fF64a1cc1;\n \n    // Load the private key from the `PRIVATE_KEY` environment variable (in .env)\n    uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\");\n \n    // Start broadcasting transactions from the deployer account\n    vm.startBroadcast(deployerPrivateKey);\n \n    ResourceId systemId = WorldResourceIdLib.encode({ typeId: RESOURCE_SYSTEM, namespace: \"\", name: \"TasksSystem\" });\n \n    bytes memory returnData = IWorld(worldAddress).call(\n      systemId,\n      abi.encodeWithSignature(\"addTask(string)\", \"Test task\")\n    );\n \n    console.log(\"The return value is:\");\n    console.logBytes(returnData);\n \n    vm.stopBroadcast();\n  }\n}\n```\n\nExplanation\n\n```\nimport { ResourceId, WorldResourceIdLib, WorldResourceIdInstance } from \"@latticexyz/world/src/WorldResourceId.sol\";\nimport { RESOURCE_SYSTEM } from \"@latticexyz/world/src/worldResourceTypes.sol\";\n.\n.\n.\nResourceId systemId = WorldResourceIdLib.encode({\n  typeId: RESOURCE_SYSTEM,\n  namespace: \"\",\n  name: \"TasksSystem\"\n});\n```\n\nCreate a `ResourceId` for the `System`.\n\n```\nbytes memory returnData =\n  IWorld(worldAddress).\n    call(systemId, abi.encodeWithSignature(\"addTask(string)\", \"Test task\"));\n```\n\nCall the `System`. The calldata is created using [`abi.encodeWithSignature` (opens in a new tab)](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-1).\n\nThe return data is of type [`bytes memory` (opens in a new tab)](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html#bytes-and-string).\n\n## Writing systems[](#writing-systems)\n\nA `System` should _not_ have any internal state, but store all of it in tables in the `World`. There are several reasons for this:\n\n- It allows a `World` to enforce access controls.\n- It allows the same `System` to be used by multiple `World` contracts.\n- Upgrades are a lot simpler when all the state is centralized outside of the `System` contract.\n\nBecause calls to systems are proxied through the `World`, some message fields don't reflect the original call. Use these substitutes:\n\n|Vanilla Solidity|`System` replacement|\n|---|---|\n|`msg.sender`|`_msgSender()`|\n|`msg.value`|`_msgValue()`|\n\nWhen calling other contracts from a `System`, be aware that if you use `delegatecall` the called contract inherits the `System`'s permissions and can modify data in the `World` on behalf of the `System`.\n\n### Calling one `System` from another[](#calling-one-system-from-another)\n\nThere are two ways to call one `System` from another one.\n\n|Call type|`call` to the `World`|`delegatecall` directly to the `System`|\n|---|---|---|\n|Permissions|those of the called `System`|those of the calling `System`|\n|`_msgSender()`|calling `System` (unless you can use `callFrom`, which is only available when the user [delegates](/world/account-delegation) to your `System`)|can use [`WorldContextProvider` (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/world/src/WorldContext.sol#L180-L203) to transfer the correct information|\n|`_msgValue()`|zero|can use [`WorldContextProvider` (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/world/src/WorldContext.sol#L180-L203) to transfer the correct information|\n|Can be used by systems in the root namespace|No (it's a security measure)|Yes|\n\n#### Calling from a root `System`[](#calling-from-a-root-system)\n\nFor [security reasons](/retrospectives/2023-09-12-register-system-vulnerability) the `World` cannot call itself. A `System` in the root namespace runs in the `World` context, and therefore cannot call the `World` either.\n\nðŸš«\n\nYou _could_ use [`delegatecall` (opens in a new tab)](https://docs.soliditylang.org/en/v0.8.16/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries), but you should only do it if it's necessary. A root `System` acts as the `World`, so a `delegatecall` from a root `System` behaves exactly like a `delegatecall` from the `World`. Any contract you `delegatecall` inherits your permissions, in this case unlimited access to the `World` and the ability to change everything.\n\nAn alternative solution is for the root `System` to do exactly what the `World` does with a normal call: check for access permission, run before hook (if configured), call the `System`, and then run the after hook (if configured). To do that, you can use [`SystemCall.callWithHooks()` (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/world/src/SystemCall.sol#L77-L114).\n\nIf you need to specify values for [`_msgSender()`](/world/reference/world-context#_msgsender) and [`_msgValue()`](/world/reference/world-context#_msgvalue) to provide for the called `System`, you can use [`WorldContextProviderLib.callWithContext` (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/world/src/WorldContext.sol#L122-L140). Note that this function is _extremely_ low level, and if you use it you have to process hooks and access control yourself.\n\n#### `SystemSwitch`[](#systemswitch)\n\nIf your `System` needs run both from the root namespace and from other namespaces, you can call other `System`s using [`SystemSwitch` (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/world-modules/src/utils/SystemSwitch.sol).\n\n1. Import `SystemSwitch`.\n    \n    ```\n    import { SystemSwitch } from \"@latticexyz/world-modules/src/utils/SystemSwitch.sol\";\n    ```\n    \n2. Import the interface for the system you wish to call.\n    \n    ```\n    import { IIncrementSystem } from \"../codegen/world/IIncrementSystem.sol\";\n    ```\n    \n3. Call the function using `SystemSwitch.call`. For example, here is how you can call [`IncrementSystem.increment()`](/templates/typescript/contracts#incrementsystemsol).\n    \n    ```\n     uint32 returnValue = abi.decode(\n       SystemSwitch.call(\n         abi.encodeCall(IIncrementSystem.increment, ())\n       ),\n       (uint32)\n     );\n    ```\n    \n    Explanation\n    \n    ```\n    abi.encodeCall(IIncrementSystem.increment, ())\n    ```\n    \n    Use [`abi.encodeCall` (opens in a new tab)](https://docs.soliditylang.org/en/latest/cheatsheet.html#abi-encoding-and-decoding-functions) to create the calldata. The first parameter is a pointer to the function. The second parameter is a [tuple (opens in a new tab)](https://docs.soliditylang.org/en/latest/control-structures.html#destructuring-assignments-and-returning-multiple-values) with the function parameters. In this case, there aren't any.\n    \n    The advantage of `abi.encodeCall` is that it checks the types of the function parameters are correct.\n    \n    ```\n    SystemSwitch.call(\n         abi.encodeCall(...)\n    )\n    ```\n    \n    Using `SystemSwitch.call` with the calldata created by `abi.encodeCall`. `SystemSwitch.call` takes care of figuring out details, such as what type of call to use.\n    \n    ```\n    uint32 retval = abi.decode(\n       SystemSwitch.call(...),\n       (uint32)\n    );\n    ```\n    \n    Use [`abi.decode` (opens in a new tab)](https://docs.soliditylang.org/en/latest/cheatsheet.html#abi-encoding-and-decoding-functions) to decode the call's return value. The second parameter is the data type (or types if there are multiple return values).\n    \n\n## Registering systems[](#registering-systems)\n\nFor a `System` to be callable from a `World` it has to be [registered (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/world/src/modules/init/implementations/WorldRegistrationSystem.sol#L115-L178). Only the [namespace owner](/world/namespaces-access-control#ownership) can register a `System` in a namespace.\n\n`System`s can be registered once per `World`, but the same system can be registered in multiple `World`s. If you need multiple instances of a `System` in the same world, you can deploy the `System` multiple times and register the individual deployments individually.\n\nMessagingExtension.s.sol\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n \nimport { Script } from \"forge-std/Script.sol\";\nimport { console } from \"forge-std/console.sol\";\nimport { IBaseWorld } from \"@latticexyz/world-modules/src/interfaces/IBaseWorld.sol\";\nimport { WorldRegistrationSystem } from \"@latticexyz/world/src/modules/core/implementations/WorldRegistrationSystem.sol\";\n \n// Create resource identifiers (for the namespace and system)\nimport { ResourceId } from \"@latticexyz/store/src/ResourceId.sol\";\nimport { WorldResourceIdLib } from \"@latticexyz/world/src/WorldResourceId.sol\";\nimport { RESOURCE_SYSTEM } from \"@latticexyz/world/src/worldResourceTypes.sol\";\n \n// For registering the table\nimport { Messages, MessagesTableId } from \"../src/codegen/index.sol\";\nimport { IStore } from \"@latticexyz/store/src/IStore.sol\";\nimport { StoreSwitch } from \"@latticexyz/store/src/StoreSwitch.sol\";\n \n// For deploying MessageSystem\nimport { MessageSystem } from \"../src/systems/MessageSystem.sol\";\n \ncontract MessagingExtension is Script {\n  function run() external {\n    uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\");\n    address worldAddress = vm.envAddress(\"WORLD_ADDRESS\");\n    WorldRegistrationSystem world = WorldRegistrationSystem(worldAddress);\n    ResourceId namespaceResource = WorldResourceIdLib.encodeNamespace(bytes14(\"messaging\"));\n    ResourceId systemResource = WorldResourceIdLib.encode(RESOURCE_SYSTEM, \"messaging\", \"MessageSystem\");\n \n    vm.startBroadcast(deployerPrivateKey);\n \n    world.registerNamespace(namespaceResource);\n    StoreSwitch.setStoreAddress(worldAddress);\n    Messages.register();\n    MessageSystem messageSystem = new MessageSystem();\n    world.registerSystem(systemResource, messageSystem, true);\n    world.registerFunctionSelector(systemResource, \"incrementMessage(string)\");\n \n    vm.stopBroadcast();\n  }\n}\n```\n\n`System` registration requires several steps:\n\n1. Create the resource ID for the `System`.\n2. Deploy the `System` contract.\n3. Use [`WorldRegistrationSystem.registerSystem` (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/world/src/modules/init/implementations/WorldRegistrationSystem.sol#L115-L178) to register the `System`. This function takes three parameters:\n    - The ResourceId for the `System`.\n    - The address of the `System` contract.\n    - Access control - whether access to the `System` is public (`true`) or limited to entities with access either to the namespace or the `System` itself (`false`).  \n        \n4. Optionally, register [function selectors](/world/function-selectors) for the `System`.\n\n### Upgrading systems[](#upgrading-systems)\n\nThe namespace owner can upgrade a `System`. This is a two-step process: deploy the contract for the new `System` and then call `registerSystem` with the same `ResourceId` as the old one and the new contract address.\n\nThis upgrade process removes the old `System` contract's access to the namespace, and gives access to the new contract. Any access granted _manually_ to the old `System` is not revoked, nor granted to the upgraded `System`.\n\n**Note:** You _should_ make sure to remove any such manually granted access. MUD access is based on the contract address, so somebody else could register a namespace they'd own, register the old `System` contract as a system in their namespace, and then abuse those permissions (if the `System` has code that can be used for that, of course).\n\nSample code\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n \nimport { Script } from \"forge-std/Script.sol\";\nimport { console } from \"forge-std/console.sol\";\nimport { System } from \"@latticexyz/world/src/System.sol\";\n \nimport { IWorld } from \"../src/codegen/world/IWorld.sol\";\nimport { Counter } from \"../src/codegen/index.sol\";\n \nimport { ResourceId, WorldResourceIdLib, WorldResourceIdInstance } from \"@latticexyz/world/src/WorldResourceId.sol\";\nimport { RESOURCE_SYSTEM } from \"@latticexyz/world/src/worldResourceTypes.sol\";\n \ncontract IncrementSystem2 is System {\n  function increment() public returns (uint32) {\n    uint32 counter = Counter.get();\n    uint32 newValue = counter + 2;\n    Counter.set(newValue);\n    return newValue;\n  }\n}\n \ncontract UpdateASystem is Script {\n  function run() external {\n    address worldAddress = 0xC14fBdb7808D9e2a37c1a45b635C8C3fF64a1cc1;\n \n    // Load the private key from the `PRIVATE_KEY` environment variable (in .env)\n    uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\");\n \n    // Start broadcasting transactions from the deployer account\n    vm.startBroadcast(deployerPrivateKey);\n \n    // Deploy IncrementSystem2\n    IncrementSystem2 incrementSystem2 = new IncrementSystem2();\n \n    ResourceId systemId = WorldResourceIdLib.encode({\n      typeId: RESOURCE_SYSTEM,\n      namespace: \"\",\n      name: \"IncrementSystem\"\n    });\n \n    IWorld(worldAddress).registerSystem(systemId, incrementSystem2, true);\n \n    vm.stopBroadcast();\n  }\n}\n```\n\nExplanation\n\n```\nimport { ResourceId, WorldResourceIdLib, WorldResourceIdInstance } from \"@latticexyz/world/src/WorldResourceId.sol\";\nimport { RESOURCE_SYSTEM } from \"@latticexyz/world/src/worldResourceTypes.sol\";\n```\n\nTo upgrade a `System` we need the resource ID for it.\n\n```\ncontract IncrementSystem2 is System {\n  function increment() public returns (uint32) {\n    uint32 counter = Counter.get();\n    uint32 newValue = counter + 2;\n    Counter.set(newValue);\n    return newValue;\n  }\n}\n```\n\nThe new `System`. It needs to implement the same `public` functions as the `System` being replaced.\n\n```\n    ...\n \n    // Deploy IncrementSystem2\n    IncrementSystem2 incrementSystem2 = new IncrementSystem2();\n```\n\nDeploy the new `System`.\n\n```\n    ResourceId systemId = WorldResourceIdLib.encode(\n      { typeId: RESOURCE_SYSTEM,\n        namespace: \"\",\n        name: \"IncrementSystem\"\n      });\n```\n\nGet the `ResourceId` for the `System`.\n\n```\n    IWorld(worldAddress).registerSystem(systemId, incrementSystem2, true);\n```\n\nRegister the new `System`. This removes the existing `System` and the access automatically granted to it.\n\n## Access control[](#access-control)\n\nWhen you register a `System`, you can specify whether it is going to be private or public.\n\n- A public `System` has no access control checks, it can be called by anybody. This is the main mechanism for user interaction with a MUD application.\n    \n- A private `System` can only be called by accounts that have access. This access can be the result of:\n    \n    - Access permission to the namespace in which the `System` is registered.\n    - Access permission specifically to the `System`.\n\nNote that `System`s have access to their own namespace by default, so public `System`s can call private `System`s in their namespace.\n\n## Root systems[](#root-systems)\n\nThe `World` uses `call` for systems in other namespaces, but `delegatecall` for those in the root namespace (`bytes14(0)`). As a result, root systems have access to the `World` contract's storage. Because of this access, root systems use [the internal `StoreCore` methods (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/store/src/StoreCore.sol), which are slightly cheaper than calling [the external `IStore` methods (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/store/src/IStore.sol) used by other systems. Note that the table libraries abstract this difference, so normally there is no reason to be concerned about it.\n\nAnother effect of having access to the storage of the `World` is that root systems could, in theory, overwrite any information in any table regardless of access control. Only the [owner of the root namespace](/world/namespaces-access-control) can register root systems. We recommend to only use the root namespace when strictly necessary.\n\n[Tables](/world/tables \"Tables\")[System Hooks](/world/system-hooks \"System Hooks\")\n\n---\n\nMIT 2023 Â© MUD\n\nSystems â€“ MUD","x":-673,"y":-1707,"width":894,"height":967,"color":"6"},
		{"id":"e5ec0044b729c4c4","type":"text","text":"```ts\nimport { ClientComponents } from \"./createClientComponents\";\nimport { SetupNetworkResult } from \"./setupNetwork\";\nimport { getComponentValue } from \"@latticexyz/recs\";\nimport { uuid } from \"@latticexyz/utils\";\nimport { toast } from \"react-hot-toast\";\nimport { usePlayerStore } from \"~~/services/store/playerStore\";\n\nexport type SystemCalls = ReturnType<typeof createSystemCalls>;\nexport function createSystemCalls(\n  { playerEntity, worldContract, waitForTransaction }: SetupNetworkResult,\n  { Player, Lore }: ClientComponents,\n) {\n  const spawn = async () => {\n    if (!playerEntity) {\n      throw new Error(\"no player\");\n    }\n    const canSpawn = getComponentValue(Player, playerEntity)?.value !== true;\n    const playerName = usePlayerStore.getState().playerName;\n\n    const lore = usePlayerStore.getState().lore;\n    if (!canSpawn) {\n      throw new Error(\"already spawned\");\n    }\n    const playerId = uuid();\n    Player.addOverride(playerId, {\n      entity: playerEntity,\n      value: { value: true },\n    });\n    const args = {\n      x: 0,\n      y: 0,\n      health: 100,\n      name: playerName,\n    };\n\n    toast.loading(\"Spawning player...\");\n    try {\n      const tx = await worldContract.write.spawnPlayer([args, lore]);\n      await waitForTransaction(tx);\n    } catch (error) {\n      console.error(\"Spawn transaction failed:\", error);\n    } finally {\n      setTimeout(() => {\n        Player.removeOverride(playerId);\n        toast.dismiss();\n        toast.success(`Player spawned! ${playerName}`);\n      }, 1000);\n    }\n  };\n\n  return {\n    spawn,\n  };\n}\n\n```","x":1249,"y":-1459,"width":752,"height":780,"color":"6"},
		{"id":"f009650d009d7f75","type":"text","text":"```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport { System } from \"@latticexyz/world/src/System.sol\";\nimport { Player, Lore, LoreData, PlayerData } from \"../codegen/index.sol\";\nimport { addressToEntityKey } from \"../addressToEntityKey.sol\";\n\ncontract SpawnPlayerSystem is System {\n  function spawnPlayer(PlayerData calldata data, LoreData calldata lore) public {\n    // Ensure the player does not already exist\n    bytes32 id = addressToEntityKey(msg.sender);\n    PlayerData memory existingPlayer = Player.get(id);\n    require(existingPlayer.health == 0, \"Player already exists\"); // Assuming health is 0 for non-existent players\n\n    // Create the player\n    Player.set(id, PlayerData({ x: data.x, y: data.y, health: data.health, name: data.name }));\n    Lore.set(id, lore.alignment, lore.backstory, lore.currentQuest);\n  }\n}\n\n```","x":273,"y":-1687,"width":476,"height":828,"color":"6"},
		{"id":"accca65f78d8dc48","type":"text","text":"Sure, let's review and potentially enhance the system calls to accommodate the newly integrated `InventorySystem` and ensure smooth orchestration with `SpawnPlayerSystem`.\n\nHere is an updated implementation of the `createSystemCalls` function:\n\n```ts\nimport { ClientComponents } from \"./createClientComponents\";\nimport { SetupNetworkResult } from \"./setupNetwork\";\nimport { getComponentValue } from \"@latticexyz/recs\";\nimport { uuid } from \"@latticexyz/utils\";\nimport { toast } from \"react-hot-toast\";\nimport { usePlayerStore } from \"~~/services/store/playerStore\";\n\nexport type SystemCalls = ReturnType<typeof createSystemCalls>;\n\nexport function createSystemCalls(\n  { playerEntity, worldContract, waitForTransaction }: SetupNetworkResult,\n  { Player, Lore, Inventory }: ClientComponents,\n) {\n  const spawn = async () => {\n    if (!playerEntity) {\n      throw new Error(\"No player entity available\");\n    }\n\n    const canSpawn = getComponentValue(Player, playerEntity)?.health === 0;\n    const playerName = usePlayerStore.getState().playerName;\n    const lore = usePlayerStore.getState().lore;\n\n    if (!canSpawn) {\n      throw new Error(\"Player already spawned\");\n    }\n\n    const playerId = uuid();\n    Player.addOverride(playerId, {\n      entity: playerEntity,\n      value: { health: 100 }, // Setting initial health\n    });\n\n    const args = {\n      x: 0,\n      y: 0,\n      health: 100,\n      name: playerName,\n    };\n\n    toast.loading(\"Spawning player...\");\n    try {\n      const tx = await worldContract.write.spawnPlayer([args, lore]);\n      await waitForTransaction(tx);\n      Inventory.set(playerId, { items: [] }); // Initializing empty inventory\n    } catch (error) {\n      console.error(\"Spawn transaction failed:\", error);\n    } finally {\n      setTimeout(() => {\n        Player.removeOverride(playerId);\n        toast.dismiss();\n        toast.success(`Player spawned! ${playerName}`);\n      }, 1000);\n    }\n  };\n\n  const addItemToInventory = async (playerId: string, item: InventoryItem) => {\n    // Ensure the player exists\n    const player = getComponentValue(Player, playerId);\n    if (!player || player.health === 0) {\n      throw new Error(\"Player does not exist\");\n    }\n\n    toast.loading(\"Adding item to inventory...\");\n    try {\n      const tx = await worldContract.write.addItemToInventory([playerId, item]);\n      await waitForTransaction(tx);\n    } catch (error) {\n      console.error(\"Add item transaction failed:\", error);\n    } finally {\n      toast.dismiss();\n      toast.success(\"Item added to inventory!\");\n    }\n  };\n\n  const removeItemFromInventory = async (playerId: string, index: number) => {\n    // Ensure the player exists\n    const player = getComponentValue(Player, playerId);\n    if (!player || player.health === 0) {\n      throw new Error(\"Player does not exist\");\n    }\n\n    toast.loading(\"Removing item from inventory...\");\n    try {\n      const tx = await worldContract.write.removeItemFromInventory([playerId, index]);\n      await waitForTransaction(tx);\n    } catch (error) {\n      console.error(\"Remove item transaction failed:\", error);\n    } finally {\n      toast.dismiss();\n      toast.success(\"Item removed from inventory!\");\n    }\n  };\n\n  const getInventory = async (playerId: string): Promise<InventoryItem[]> => {\n    // Ensure the player exists\n    const player = getComponentValue(Player, playerId);\n    if (!player || player.health === 0) {\n      throw new Error(\"Player does not exist\");\n    }\n\n    try {\n      const inventory = await worldContract.read.getInventoryItems([playerId]);\n      return inventory;\n    } catch (error) {\n      console.error(\"Get inventory failed:\", error);\n      throw error;\n    }\n  };\n\n  return {\n    spawn,\n    addItemToInventory,\n    removeItemFromInventory,\n    getInventory,\n  };\n}\n```\n\n### Key Points:\n\n1. **`spawn` Method:**\n   - This method ensures a player is spawned only if they don't already exist.\n   - An initial empty inventory is set up for the new player immediately after spawning.\n\n2. **`addItemToInventory` Method:**\n   - Checks for player existence before adding the item.\n   - Adds toast notifications for loading, success, and error states.\n\n3. **`removeItemFromInventory` Method:**\n   - Ensures the player exists and handles removing items from the inventory.\n   - Includes toast notifications for consistent user feedback.\n\n4. **`getInventory` Method:**\n   - Safely retrieves a player's inventory.\n   - Handles player existence checks, ensuring consistent error handling.\n\nBy incorporating these checks and feedback mechanisms, the systems are well-orchestrated, providing a seamless user experience and ensuring data integrity across player, lore, and inventory systems.","x":797,"y":-1399,"width":380,"height":438,"color":"6"},
		{"id":"750425d9f84a2878","type":"text","text":"```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\nimport { Script } from \"forge-std/Script.sol\";\nimport { console } from \"forge-std/console.sol\";\nimport { StoreSwitch } from \"@latticexyz/store/src/StoreSwitch.sol\";\nimport { IWorld } from \"../src/codegen/world/IWorld.sol\";\nimport { SpawnPlayerSystem } from \"../src/systems/SpawnPlayerSystem.sol\";\n\nimport { Player, Lore } from \"../src/codegen/index.sol\";\n\ncontract PostDeploy is Script {\n  function run(address worldAddress) external {\n    // Specify a store so that you can use tables directly in PostDeploy\n    StoreSwitch.setStoreAddress(worldAddress);\n\n    // Load the private key from the `PRIVATE_KEY` environment variable (in .env)\n    uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\");\n    vm.startBroadcast(deployerPrivateKey);\n\n    // Deploy the SpawnPlayerSystem contract\n    //SpawnPlayerSystem spawnPlayerSystem = new SpawnPlayerSystem();\n    //console.log(\"SpawnPlayerSystem deployed to:\", address(spawnPlayerSystem));\n\n    // Register the SpawnPlayerSystem in the World\n    //IWorld(worldAddress).registerSystem(\"spawnPlayer\", address(spawnPlayerSystem));\n\n    // Spawn a player\n    bytes32 playerId = keccak256(abi.encodePacked(\"player1\"));\n    int32 x = 0;\n    int32 y = 0;\n    uint32 health = 100;\n    string memory name = \"PlayerOne\";\n    Player.set(playerId, x, y, health, name);\n    Lore.set(playerId, \"chaotic good\", \"This is the first player.\", \"save the world\");\n    //console.log(\"Player spawned:\", playerId, name, x, y, health);\n\n    vm.stopBroadcast();\n  }\n}\n```","x":-707,"y":-279,"width":980,"height":436,"color":"6"},
		{"id":"d069b06ce86fa6dc","type":"text","text":"```ts\nimport { defineWorld } from \"@latticexyz/world\";\n\n// Define enums for better type safety and readability\nconst EntityType = [\"Player\"];\n\nexport default defineWorld({\n  enums: {\n    EntityType,\n  },\n  tables: {\n    Player: {\n      schema: {\n        id: \"bytes32\",\n        x: \"int32\",\n        y: \"int32\",\n        health: \"uint32\",\n        name: \"string\",\n      },\n      key: [\"id\"],\n    },\n    Lore: {\n      schema: {\n        id: \"bytes32\",\n        alignment: \"string\",\n        backstory: \"string\",\n        currentQuest: \"string\",\n      },\n      key: [\"id\"],\n    },\n    Inventory: {\n      schema: {\n        ownerId: \"bytes32\",\n        itemIds: \"bytes32[]\", // Changed to bytes32[] for dynamic length\n      },\n      key: [\"ownerId\"],\n    },\n    Item: {\n      schema: {\n        itemId: \"bytes32\", // Changed to bytes32 for a more consistent key type\n        itemCount: \"uint256\",\n        itemName: \"string\",\n      },\n      key: [\"itemId\"],\n    },\n  },\n  deploy: {\n    upgradeableWorldImplementation: true,\n  },\n});\n\n```","x":-1969,"y":362,"width":540,"height":832,"color":"6"},
		{"id":"df8a95bf30102431","type":"text","text":"Review system calls to handle the new systems","x":1485,"y":-459,"width":393,"height":362,"color":"4"},
		{"id":"49a51d0a347db829","type":"text","text":"Certainly! Let's extend the `PostDeploy` script to initialize a player with an inventory when deploying contracts. \n\nAssuming the inventory items and the `InventorySystem` have already been defined and imported appropriately, the following script will set up a player, assign them an empty inventory, and optionally add an initial item(s) to their inventory.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\nimport { Script } from \"forge-std/Script.sol\";\nimport { console } from \"forge-std/console.sol\";\nimport { StoreSwitch } from \"@latticexyz/store/src/StoreSwitch.sol\";\nimport { IWorld } from \"../src/codegen/world/IWorld.sol\";\nimport { SpawnPlayerSystem } from \"../src/systems/SpawnPlayerSystem.sol\";\nimport { InventorySystem } from \"../src/systems/InventorySystem.sol\";\n\nimport { Player, Lore, Inventory, InventoryItem, InventoryData } from \"../src/codegen/index.sol\";\n\ncontract PostDeploy is Script {\n    function run(address worldAddress) external {\n        // Specify a store so that you can use tables directly in PostDeploy\n        StoreSwitch.setStoreAddress(worldAddress);\n\n        // Load the private key from the `PRIVATE_KEY` environment variable (in .env)\n        uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\");\n        vm.startBroadcast(deployerPrivateKey);\n\n        // Deploy the SpawnPlayerSystem contract\n        SpawnPlayerSystem spawnPlayerSystem = new SpawnPlayerSystem();\n        console.log(\"SpawnPlayerSystem deployed to:\", address(spawnPlayerSystem));\n\n        // Deploy the InventorySystem contract\n        InventorySystem inventorySystem = new InventorySystem();\n        console.log(\"InventorySystem deployed to:\", address(inventorySystem));\n\n        // Register the systems in the World\n        IWorld(worldAddress).registerSystem(\"spawnPlayer\", address(spawnPlayerSystem));\n        IWorld(worldAddress).registerSystem(\"inventory\", address(inventorySystem));\n\n        // Spawn a player\n        bytes32 playerId = keccak256(abi.encodePacked(\"player1\"));\n        int32 x = 0;\n        int32 y = 0;\n        uint32 health = 100;\n        string memory name = \"PlayerOne\";\n        Player.set(playerId, x, y, health, name);\n        Lore.set(playerId, \"chaotic good\", \"This is the first player.\", \"save the world\");\n        console.log(\"Player spawned: \", playerId, name, x, y, health);\n\n        // Initialize an empty inventory for the player\n        Inventory.set(playerId, InventoryData(new InventoryItem[](0)));\n        console.log(\"Inventory initialized for player: \", playerId);\n\n        // Optionally add initial items to the player's inventory\n        InventoryItem memory item1 = InventoryItem(\"Sword\", 1);\n        InventoryItem memory item2 = InventoryItem(\"Shield\", 1);\n        InventorySystem(worldAddress).addItemToInventory(playerId, item1);\n        InventorySystem(worldAddress).addItemToInventory(playerId, item2);\n        console.log(\"Initial items added to inventory for player: \", playerId);\n\n        vm.stopBroadcast();\n    }\n}\n```\n\n### Explanation\n\n1. **Deployment & Registration:**\n    - The `SpawnPlayerSystem` and `InventorySystem` contracts are deployed and registered with the `IWorld` contract.\n  \n2. **Player Initialization:**\n    - A new player is spawned with the specified parameters.\n    - An entry in the `Lore` table is also created for the player.\n\n3. **Inventory Initialization:**\n    - An empty inventory is initialized for the player.\n\n4. **Adding Initial Items (optional):**\n    - Two initial items, a \"Sword\" and a \"Shield,\" are added to the player's inventory.\n    - The `addItemToInventory` function of `InventorySystem` is called to add these items to the player's inventory.\n\n### Final Considerations\n\n- Make sure the imports align with your actual project structure.\n- Ensure that the `InventorySystem` functions such as `addItemToInventory` accept parameters in the format provided.\n- Adjust the `console.log` statements as necessary to fit your logging requirements.","x":331,"y":-798,"width":656,"height":655,"color":"6"},
		{"id":"339494b8079c8ec3","type":"text","text":"Sure, to incorporate the new system calls for inventory management into the user interface, we need to update various components and ensure that the inventory functionality integrates smoothly. We'll focus particularly on updating the `GameBoard`, `PlayerList`, and create necessary components to handle inventory display and operations.\n\n### 1. Update `GameBoard.tsx`\n\nWe'll ensure `GameBoard` accommodates the new functionalities by invoking the system calls where necessary.\n\n```ts\nimport React from \"react\";\nimport PlayerInput from \"../PlayerInput\";\nimport PlayerList from \"../PlayerList\";\nimport { useMUD } from \"./MUDContext\";\n\nconst GameBoard = () => {\n  const {\n    network: { useStore, tables },\n  } = useMUD();\n\n  const records = useStore(state => Object.values(state.getRecords(tables.Player)));\n\n  return (\n    <div className=\"container flex flex-row mx-auto w-full h-full\">\n      <PlayerInput />\n      <PlayerList players={records} />\n    </div>\n  );\n};\n\nexport default GameBoard;\n```\n\nThis component structure remains largely intact, as we're focusing on `PlayerList` for inventory management.\n\n### 2. Update `PlayerList.tsx`\n\nWe'll extend the `PlayerList` component to display inventory details and provide options to add or remove items.\n\n```ts\nimport React from \"react\";\nimport Image from \"next/image\";\nimport LoreDisplay from \"./LoreDisplay\";\nimport InventoryDisplay from \"./InventoryDisplay\"; // New component to manage inventory display\nimport { pixelArt } from \"@dicebear/collection\";\nimport { createAvatar } from \"@dicebear/core\";\n\nconst PlayerList = (props: { players: any }) => {\n  const { players } = props;\n\n  return (\n    <div className=\"p-5 bg-gray-100 rounded-lg shadow-md overflow-scroll max-h-svh flex justify-items-end\">\n      <h2 className=\"mb-5 text-2xl font-bold text-gray-800\">Players:</h2>\n      <ul>\n        {players.map(player => {\n          const avatarSvg = createAvatar(pixelArt, {\n            seed: player.value.name,\n            dataUri: true,\n          });\n          return (\n            <li key={player.id} className=\"flex p-4 mb-4 bg-white rounded-lg shadow-sm hover:bg-gray-50\">\n              <div className=\"flex-1\">\n                <h3 className=\"text-xl font-semibold text-blue-600\">{player.value.name}</h3>\n                <p className=\"mt-2 text-gray-700\">\n                  <strong>Coordinates:</strong> (x: {player.value.x}, y: {player.value.y})\n                </p>\n                <p className=\"mt-1 text-gray-700\">\n                  <strong>Health:</strong> {player.value.health}\n                </p>\n                <LoreDisplay entityId={player.key.id} />\n                <InventoryDisplay playerId={player.key.id} /> {/* Display inventory */}\n              </div>\n              <div className=\"ml-4\">\n                <Image\n                  className=\"w-12 h-12 rounded-full\"\n                  src={avatarSvg.toDataUriSync()}\n                  alt={`${player.value.name}'s avatar`}\n                  width={48}\n                  height={48}\n                />\n              </div>\n            </li>\n          );\n        })}\n      </ul>\n    </div>\n  );\n};\n\nexport default PlayerList;\n```\n\n### 3. Create `InventoryDisplay.tsx`\n\nThis new component will handle displaying the inventory and providing options for adding and removing items.\n\n```ts\nimport React, { useState, useEffect } from \"react\";\nimport { useMUD } from \"./mud/MUDContext\";\n\nconst InventoryDisplay = ({ playerId }) => {\n  const {\n    network: { systemCalls },\n  } = useMUD();\n\n  const [inventory, setInventory] = useState([]);\n  const [newItemName, setNewItemName] = useState(\"\");\n  const [newItemCount, setNewItemCount] = useState(1);\n\n  useEffect(() => {\n    const fetchInventory = async () => {\n      try {\n        const items = await systemCalls.getInventory(playerId);\n        setInventory(items);\n      } catch (error) {\n        console.error(\"Failed to fetch inventory\", error);\n      }\n    };\n    fetchInventory();\n  }, [playerId, systemCalls]);\n\n  const handleAddItem = async () => {\n    try {\n      await systemCalls.addItemToInventory(playerId, { itemName: newItemName, itemCount: newItemCount });\n      setNewItemName(\"\");\n      setNewItemCount(1);\n    } catch (error) {\n      console.error(\"Failed to add item\", error);\n    }\n  };\n\n  const handleRemoveItem = async (index) => {\n    try {\n      await systemCalls.removeItemFromInventory(playerId, index);\n    } catch (error) {\n      console.error(\"Failed to remove item\", error);\n    }\n  };\n\n  return (\n    <div className=\"mt-5 p-3 bg-gray-200 rounded-lg shadow-sm\">\n      <h3 className=\"text-lg font-bold text-gray-800\">Inventory:</h3>\n      <ul>\n        {inventory.map((item, index) => (\n          <li key={index} className=\"flex justify-between py-1 border-b\">\n            <span>{item.itemName} (x{item.itemCount})</span>\n            <button\n              className=\"ml-2 text-red-600\"\n              onClick={() => handleRemoveItem(index)}\n            >\n              Remove\n            </button>\n          </li>\n        ))}\n      </ul>\n      <div className=\"mt-4\">\n        <h4 className=\"text-md font-bold text-gray-800\">Add New Item:</h4>\n        <input\n          type=\"text\"\n          className=\"border rounded p-1 mr-2\"\n          placeholder=\"Item Name\"\n          value={newItemName}\n          onChange={(e) => setNewItemName(e.target.value)}\n        />\n        <input\n          type=\"number\"\n          className=\"border rounded p-1 mr-2\"\n          placeholder=\"Count\"\n          value={newItemCount}\n          onChange={(e) => setNewItemCount(parseInt(e.target.value))}\n        />\n        <button className=\"btn\" onClick={handleAddItem}>\n          Add Item\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default InventoryDisplay;\n```\n\n### 4. Updating `PlayerInput.tsx` (if needed)\n\nIf you want to add functionalities related to the inventory within `PlayerInput`, you can do so similarly. For example, allowing initial items to be set upon player creation. \n\n```ts\nimport React, { useState } from \"react\";\nimport { useMUD } from \"./mud/MUDContext\";\nimport { usePlayerStore } from \"~~/services/store/playerStore\";\n\nconst PlayerInput = () => {\n  const playerName = usePlayerStore(state => state.playerName);\n  const setPlayerName = usePlayerStore(state => state.setPlayerName);\n  const { lore, setLore } = usePlayerStore();\n  const { systemCalls: { spawn } } = useMUD();\n\n  return (\n    <div className=\"p-5 form-control\">\n      <h2 className=\"mb-5 text-2xl font-bold text-gray-800\">Edit Lore:</h2>\n      <div>\n        <label className=\"label\">Player Name</label>\n        <input\n          className=\"input\"\n          type=\"text\"\n          value={playerName}\n          onChange={e => setPlayerName(e.target.value)}\n          placeholder=\"Enter player name\"\n        />\n      </div>\n      <div>\n        <label className=\"label\">Alignment:</label>\n        <input\n          className=\"input\"\n          value={lore.alignment}\n          onChange={e => setLore({ ...lore, alignment: e.target.value })}\n        />\n      </div>\n      <div>\n        <label className=\"label\">Backstory:</label>\n        <textarea\n          className=\"input\"\n          value={lore.backstory}\n          onChange={e => setLore({ ...lore, backstory: e.target.value })}\n        />\n      </div>\n      <div>\n        <label className=\"label\">Current Quest:</label>\n        <input\n          className=\"input\"\n          value={lore.currentQuest}\n          onChange={e => setLore({ ...lore, currentQuest: e.target.value })}\n        />\n      </div>\n\n      <button className=\"btn\" onClick={spawn}>\n        Spawn Player\n      </button>\n    </div>\n  );\n};\n\nexport default PlayerInput;\n```\n\n### Summary\n\n- *GameBoard*: No changes needed since it already incorporates nested components.\n- *PlayerList*: Updated to include `InventoryDisplay`.\n- *InventoryDisplay*: New component to manage item display and CRUD operations.\n- *PlayerInput*: Simplified for player creation, further integration can be added if initial items need to be set.\n\nThis approach ensures the interface is updated to use the new system calls for inventory management, providing a cohesive experience for the user.","x":-836,"y":385,"width":1200,"height":1182,"color":"6"},
		{"id":"a550d11dd2221f65","type":"text","text":"```ts\nimport React from \"react\";\nimport Image from \"next/image\";\nimport LoreDisplay from \"./LoreDisplay\";\nimport { pixelArt } from \"@dicebear/collection\";\nimport { createAvatar } from \"@dicebear/core\";\n\nconst PlayerList = (props: { players: any }) => {\n  const { players } = props;\n  return (\n    <div className=\"p-5 bg-gray-100 rounded-lg shadow-md overflow-scroll max-h-svh flex justify-items-end\">\n      <h2 className=\"mb-5 text-2xl font-bold text-gray-800\">Players:</h2>\n      <ul>\n        {players.map(player => {\n          const avatarSvg = createAvatar(pixelArt, {\n            seed: player.value.name,\n            dataUri: true,\n          });\n          return (\n            <li key={player.id} className=\"flex p-4 mb-4 bg-white rounded-lg shadow-sm hover:bg-gray-50\">\n              <div className=\"flex-1\">\n                <h3 className=\"text-xl font-semibold text-blue-600\">{player.value.name}</h3>\n                <p className=\"mt-2 text-gray-700\">\n                  <strong>Coordinates:</strong> (x: {player.value.x}, y: {player.value.y})\n                </p>\n                <p className=\"mt-1 text-gray-700\">\n                  <strong>Health:</strong> {player.value.health}\n                </p>\n                <LoreDisplay entityId={player.key.id} />\n              </div>\n              <div className=\"ml-4\">\n                <Image\n                  className=\"w-12 h-12 rounded-full\"\n                  src={avatarSvg.toDataUriSync()}\n                  alt={`${player.value.name}'s avatar`}\n                  width={48}\n                  height={48}\n                />\n              </div>\n            </li>\n          );\n        })}\n      </ul>\n    </div>\n  );\n};\n```","x":1541,"y":258,"width":281,"height":254,"color":"6"},
		{"id":"69e4fb7c299feb00","type":"text","text":"```ts\nimport React from \"react\";\nimport PlayerInput from \"../PlayerInput\";\nimport PlayerList from \"../PlayerList\";\nimport { useMUD } from \"./MUDContext\";\n\nconst GameBoard = () => {\n  const {\n    network: { useStore, tables },\n  } = useMUD();\n\n  const records = useStore(state => Object.values(state.getRecords(tables.Player)));\n\n  return (\n    <div className=\"container flex flex-row mx-auto w-full h-full\">\n      <PlayerInput />\n      <PlayerList players={records} />\n    </div>\n  );\n};\n\nexport default GameBoard;\n```","x":1527,"y":385,"width":703,"height":540,"color":"6"}
	],
	"edges":[
		{"id":"502f6e3663386985","fromNode":"ea639d2dad2e5541","fromSide":"top","toNode":"ef1c5c10dfce25f6","toSide":"bottom"},
		{"id":"fc43430f1f1bc97b","fromNode":"36dd2d2be3827888","fromSide":"top","toNode":"ef1c5c10dfce25f6","toSide":"bottom"},
		{"id":"604dbb5e89a46c8e","fromNode":"ef1c5c10dfce25f6","fromSide":"top","toNode":"339494b8079c8ec3","toSide":"bottom"},
		{"id":"451db0f12f035d84","fromNode":"69e4fb7c299feb00","fromSide":"top","toNode":"ef1c5c10dfce25f6","toSide":"bottom"},
		{"id":"cd30573845479ab7","fromNode":"a550d11dd2221f65","fromSide":"top","toNode":"ef1c5c10dfce25f6","toSide":"bottom"},
		{"id":"a25c07cfde425793","fromNode":"df8a95bf30102431","fromSide":"bottom","toNode":"ef1c5c10dfce25f6","toSide":"right"},
		{"id":"17f7b3526a6a1022","fromNode":"fdb701df9e5053a6","fromSide":"bottom","toNode":"df8a95bf30102431","toSide":"top"},
		{"id":"24a4ce621887d78b","fromNode":"fdb701df9e5053a6","fromSide":"right","toNode":"e40614becf9e9231","toSide":"left"},
		{"id":"91e661f8f0c7baa8","fromNode":"f009650d009d7f75","fromSide":"bottom","toNode":"fdb701df9e5053a6","toSide":"top"},
		{"id":"0421e5ae0774ddd4","fromNode":"b9e3dd1da8ddf496","fromSide":"bottom","toNode":"fdb701df9e5053a6","toSide":"top"},
		{"id":"82be5ccce099db49","fromNode":"d069b06ce86fa6dc","fromSide":"top","toNode":"fdb701df9e5053a6","toSide":"left"},
		{"id":"45520caacfbc3186","fromNode":"ac01609e1754f004","fromSide":"bottom","toNode":"fdb701df9e5053a6","toSide":"top"},
		{"id":"5700409516428c69","fromNode":"e40614becf9e9231","fromSide":"right","toNode":"49a51d0a347db829","toSide":"left"},
		{"id":"537235148be174a3","fromNode":"750425d9f84a2878","fromSide":"top","toNode":"e40614becf9e9231","toSide":"bottom"},
		{"id":"b1a5188441d78879","fromNode":"ac01609e1754f004","fromSide":"bottom","toNode":"df8a95bf30102431","toSide":"left"},
		{"id":"8bd2bc9f3be392a6","fromNode":"e5ec0044b729c4c4","fromSide":"bottom","toNode":"df8a95bf30102431","toSide":"top"},
		{"id":"ca1f61bcdaa86323","fromNode":"accca65f78d8dc48","fromSide":"bottom","toNode":"df8a95bf30102431","toSide":"top"},
		{"id":"b5e107c550bbbd09","fromNode":"d069b06ce86fa6dc","fromSide":"top","toNode":"df8a95bf30102431","toSide":"left"}
	]
}