{
	"nodes":[
		{"id":"8f40a42034fe64df","type":"group","x":-2298,"y":-1846,"width":2218,"height":3286,"label":"Untitled group"},
		{"id":"8a14e06e456373e1","type":"text","text":"Review the action plan and create an updated mud.config.ts for the Trading and dynamic quest components","x":-2069,"y":-1000,"width":351,"height":260,"color":"3"},
		{"id":"855f1a7fcfbd979e","type":"text","text":"# TABLE LIBRARIES\n\nMethods on [`StoreCore`](https://mud.dev/references/store-core) and [`IStore`](https://mud.dev/references/store) use raw bytes as input and output types. This is to allow using the same methods for different types of tables types without native support for generics in Solidity, but it can be inconvenient to work with. For this reason MUD automatically generates a library for each table that provides typed methods corresponding to the table's key and value types.\n\n## CONFIG[](https://mud.dev/store/table-libraries#config)\n\nTable libraries are generated by the [`tablegen`](https://mud.dev/cli/tablegen) CLI. The [CLI config](https://mud.dev/cli/config) section goes into more detail on the available configuration options.\n\nTo illustrate table library functionality on this page, we'll use two example tables with the following configurations:\n\nPosition\n\n```\nschema: {  entity: \"address\",   // Two static length fields  x: \"uint32\",  y: \"uint32\",},key: [\"entity\"],\n```\n\nInventory\n\n```\nschema: {  entity: \"address\",   // One dynamic length field  slots: \"uint8[]\",},key: [\"entity\"],\n```\n\n### SINGLETON TABLES[](https://mud.dev/store/table-libraries#singleton-tables)\n\nWhen you just need to store a single value (for example, the world map or the name of an in-game currency), you use a singleton table, a table whose key schema is empty. With an empty key schema there is just one record.\n\nCounter\n\n```\nschema: {  value: \"uint32\",},key: [],\n```\n\n## USAGE[](https://mud.dev/store/table-libraries#usage)\n\n### IMPORTING THE LIBRARY[](https://mud.dev/store/table-libraries#importing-the-library)\n\nBy default table libraries are generated into a `codegen/tables` directory in the contract directory. This can be configured with the `codegenDirectory` option in the [config](https://mud.dev/cli/config). The library name corresponds to the table's key in the table config.\n\n```\nimport { Position } from \"./codegen/tables/Position.sol\";import { Inventory } from \"./codegen/tables/Inventory.sol\";\n```\n\nFor convenience, the [`tablegen`](https://mud.dev/cli/tablegen) CLI also generates an `index.sol` file that re-exports all the generated table libraries.\n\n```\nimport { Position, Inventory } from \"./codegen/tables/index.sol\";\n```\n\n### REGISTERING THE TABLE[](https://mud.dev/store/table-libraries#registering-the-table)\n\nBefore using the table library, it must be registered once in the Store. This happens automatically as part of the [deploy CLI](https://mud.dev/cli/deploy), but if you're using the table library in a [Module](https://mud.dev/world/modules) or a contract that's not deployed by MUD, you'll need to register it manually.\n\n```\nPosition.register();Inventory.register();\n```\n\nThe table library will detect the `Store` context automatically (via [`StoreSwitch`](https://mud.dev/store/table-libraries#storeswitch)).\n\n### READING DATA[](https://mud.dev/store/table-libraries#reading-data)\n\nTable libraries provide typed methods for reading data from the `Store`.\n\n#### READ FULL RECORD[](https://mud.dev/store/table-libraries#read-full-record)\n\nTo read the entire record, use the `get` method. If the table's value schema contains more than one field, the method returns a struct with the corresponding fields.\n\n```\nimport { Position, PositionData } from \"./codegen/tables/Position.sol\"; address entity = address(0x1234);PositionData memory position = Position.get(entity);\n```\n\n#### READ INDIVIDUAL FIELDS[](https://mud.dev/store/table-libraries#read-individual-fields)\n\nTo read a single field, use the `get` method with the field name as a suffix.\n\n```\nimport { Position } from \"./codegen/tables/Position.sol\"; address entity = address(0x1234);uint32 x = Position.getX(entity);\n```\n\n#### READ LENGTH OF DYNAMIC LENGTH FIELD[](https://mud.dev/store/table-libraries#read-length-of-dynamic-length-field)\n\nTo read the length of a dynamic length field, use the `length` method with the field name as a suffix.\n\n```\nimport { Inventory } from \"./codegen/tables/Inventory.sol\"; address entity = address(0x1234);uint256 length = Inventory.lengthSlots(entity);\n```\n\n#### READ INDIVIDUAL ELEMENTS OF DYNAMIC LENGTH FIELD[](https://mud.dev/store/table-libraries#read-individual-elements-of-dynamic-length-field)\n\nTo read individual fields of a dynamic length field, use the `getItem` method with the field name as a suffix and the index as an argument.\n\n```\nimport { Inventory } from \"./codegen/tables/Inventory.sol\"; address entity = address(0x1234);uint8 item = Inventory.getItemSlots(entity, 0);\n```\n\n### WRITING DATA[](https://mud.dev/store/table-libraries#writing-data)\n\nTable libraries provide typed methods for writing data to the `Store`.\n\n#### WRITE FULL RECORD[](https://mud.dev/store/table-libraries#write-full-record)\n\nTo write the entire record, use the `set` method. There is a variant of this method that accepts a struct, and a variant that accepts the individual fields.\n\n```\nimport { Position, PositionData } from \"./codegen/tables/Position.sol\"; address entity = address(0x1234); // set with individual fieldsPosition.set(entity, 1, 2); // or set with structPosition.set(entity, PositionData(1,2));\n```\n\n#### WRITE INDIVIDUAL FIELDS[](https://mud.dev/store/table-libraries#write-individual-fields)\n\nTo write a single field, use the `set` method with the field name as a suffix.\n\n```\nimport { Position } from \"./codegen/tables/Position.sol\"; address entity = address(0x1234);Position.setX(entity, 1);\n```\n\n#### WRITE INDIVIDUAL ELEMENTS OF DYNAMIC LENGTH FIELD[](https://mud.dev/store/table-libraries#write-individual-elements-of-dynamic-length-field)\n\nTo write individual fields of a dynamic length field, use the `update` method with the field name as a suffix and the index as an argument.\n\n```\nimport { Inventory } from \"./codegen/tables/Inventory.sol\"; address entity = address(0x1234);Inventory.updateSlots(entity, 0, 1);\n```\n\n#### PUSH TO DYNAMIC LENGTH FIELD[](https://mud.dev/store/table-libraries#push-to-dynamic-length-field)\n\nTo push a new element to a dynamic length field, use the `push` method with the field name as a suffix.\n\n```\nimport { Inventory } from \"./codegen/tables/Inventory.sol\"; address entity = address(0x1234);Inventory.pushSlots(entity, 1);\n```\n\n#### POP FROM DYNAMIC LENGTH FIELD[](https://mud.dev/store/table-libraries#pop-from-dynamic-length-field)\n\nTo remove the last element from a dynamic length field, use the `pop` method with the field name as a suffix.\n\n```\nimport { Inventory } from \"./codegen/tables/Inventory.sol\"; address entity = address(0x1234);Inventory.popSlots(entity);\n```\n\nNote that this method does not return the popped element. If you need to access the popped element, use the `getItem` method before calling `pop`.\n\n```\nimport { Inventory } from \"./codegen/tables/Inventory.sol\"; address entity = address(0x1234);uint256 length = Inventory.lengthSlots(entity);uint8 lastItem = Inventory.getItemSlots(entity,  length - 1);Inventory.popSlots(entity);\n```\n\n## ADVANCED[](https://mud.dev/store/table-libraries#advanced)\n\n### STORESWITCH[](https://mud.dev/store/table-libraries#storeswitch)\n\nTable libraries internally use the `StoreSwitch` library to write data to the Store. `StoreSwitch` detects whether the library is called from within a `Store` contract or from an external contract that has a reference to the `Store` contract.\n\n1. If the library is called from within a `Store` contract, `StoreSwitch` accesses the store directly via the [internal `StoreCore` library](https://mud.dev/store/reference/store-core).\n2. If the library is called from a contract that has a fixed reference to a specific external `Store` contract, `StoreSwitch` accesses this `Store` via the [external `IStore` interface](https://mud.dev/store/reference/store).\n3. If `msg.sender` is a `Store` contract, `StoreSwitch` accesses the `Store` via the caller's address via the [external `IStore` interface](https://mud.dev/store/reference/store).\n\nTo fix a reference to a specific `Store` contract (2), use the `StoreSwitch.setStoreAddress` method in your contract.\n\n```\nimport { StoreSwitch } from \"@latticexyz/store/src/StoreSwitch.sol\"; StoreSwitch.setStoreAddress(STORE_ADDRESS);\n```\n\nThis can be useful to test libraries using table libraries in isolation, by setting the `Store` address in the test contract to a mock `Store` contract. This happens automatically in the [`MudTest`](https://mud.dev/cli/test) setup.","x":-2200,"y":-1760,"width":307,"height":429,"color":"6"},
		{"id":"b3f0de196305c8f3","type":"text","text":"# TABLES\n\nEach piece of data in `Store` is stored as a _record_ in a _table_. You can think of tables in two ways, either [as a relational database](https://mud.dev/store/data-model) or as a key-value store.\n\n- Each table is identified by a unique `ResourceId tableId`.\n- Each record in a table is identified by a unique `bytes32[] keyTuple`. You can think of the key tuple as a composite key in a relational database, or as a nested mapping in a key-value store.\n- Each table has a value schema (all the `schema` fields that aren't part of the `key`) that defines the types of data stored in the table. You can think of the value schema as the column types in a table in a relational database, or the type of structs stored in a key-value store.\n\nTables are registered in the `Store` contract at runtime. When a table is registered, its ID, key and value types, as well as key and field names are stored in the internal `Tables` table. This emits an event that can be used by [offchain indexers](https://mud.dev/services/indexer) to start [replicating the state](https://mud.dev/guides/replicating-onchain-state) of the new table.\n\nThe recommended way of reading from tables and writing to tables is via the [typed table libraries](https://mud.dev/store/table-libraries). However, it is also possible to use the low-level [`IStore` (external)](https://mud.dev/store/reference/store) or [`StoreCore` (internal)](https://mud.dev/store/reference/store-core) API directly.\n\n⚠️\n\nOnce a table is created its schema is _immutable_. If you need to add fields to an existing table, create a new table with the same key schema and the new fields in the value schema, and retrieve from both tables to get the complete value. If you need to delete fields, just have your code ignore them.\n\n## TYPES OF TABLES[](https://mud.dev/store/tables#types-of-tables)\n\nThere are two types of tables in `Store`: _Onchain tables_ and _offchain tables_. We often omit the prefix from onchain tables and just call them tables.\n\nAs the name suggests, **onchain tables** store their state onchain, in the `Store` contract. In addition, an event is emitted on every write operation, to allow [offchain indexers](https://mud.dev/services/indexer) to [replicate the onchain state](https://mud.dev/guides/replicating-onchain-state).\n\n**Offchain tables** on the other hand don't store any state onchain, but only emit the events for [offchain indexers](https://mud.dev/services/indexer). This makes them suitable for use cases where data doesn't need to be retrieved onchain, but should still be synchronized from the `Store` contract to [offchain indexers](https://mud.dev/services/indexer).\n\nOnchain you can write to offchain tables with the same methods as onchain tables, except for reading data and modifying partial data in a dynamic field.","x":-1868,"y":-1760,"width":321,"height":429,"color":"6"},
		{"id":"cfdb92b92c39180e","type":"text","text":"Based on your notes, here is an action plan for implementing new features using the framework described in your [[CodeReport]]:\n### Action Plan for New Features\n#### 1. **Feature: Enhanced Inventory Management**\n- **Objective:** Improve the inventory system to support item categorization, stackable items, and inventory limits.\n- **Steps:**\n1. **Define New Schemas:**\n- Update `mud.config.ts` to include new fields for item categories and stack limits.\n```typescript\nInventory: {\nschema: {\nownerId: \"bytes32\",\nitems: \"Item[]\",\nmaxCapacity: \"uint256\",\n},\nkey: [\"ownerId\"],\n},\nItem: {\nschema: {\nitemId: \"uint256\",\nitemCount: \"uint256\",\nitemName: \"string\",\ncategory: \"string\",\nstackLimit: \"uint256\",\n},\nkey: [\"itemId\"],\n},\n```\n2. **Update Solidity Contract:**\n- Modify `InventorySystem.sol` to handle item stacking and enforce inventory limits.\n```solidity\nfunction addItemToInventory(bytes32 ownerId, uint256 itemId, uint256 count) public {\nInventoryData memory inventory = Inventory.get(ownerId);\n// Check if the item already exists and stack it\nuint256 index = findIndex(inventory.items, itemId);\nif (index < inventory.items.length) {\nrequire(inventory.items[index].itemCount + count <= inventory.items[index].stackLimit, \"Exceeds stack limit\");\ninventory.items[index].itemCount += count;\n} else {\nrequire(inventory.items.length < inventory.maxCapacity, \"Inventory full\");\ninventory.items.push(Item({itemId: itemId, itemCount: count, itemName: \"\", category: \"\", stackLimit: 0}));\n}\nInventory.set(ownerId, inventory);\n}\n```\n3. **Implement Client-Side Logic:**\n- Update the client-side code to handle new inventory features, such as displaying item categories and stack counts.\n#### 2. **Feature: Player Trading System**\n- **Objective:** Enable players to trade items with each other.\n- **Steps:**\n1. **Define New Schemas:**\n- Add a new table for trade offers in `mud.config.ts`.\n```typescript\nTradeOffer: {\nschema: {\nofferId: \"bytes32\",\nfromPlayer: \"bytes32\",\ntoPlayer: \"bytes32\",\nofferedItems: \"Item[]\",\nrequestedItems: \"Item[]\",\nstatus: \"string\", // \"pending\", \"accepted\", \"rejected\"\n},\nkey: [\"offerId\"],\n},\n```\n2. **Create Trade System Contract:**\n- Implement a new contract `TradeSystem.sol` to handle trade offers.\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport { System } from \"@latticexyz/world/src/System.sol\";\nimport { TradeOffer, TradeOfferData, Inventory, InventoryData } from \"../codegen/index.sol\";\nimport { addressToEntityKey } from \"../addressToEntityKey.sol\";\ncontract TradeSystem is System {\nfunction createTradeOffer(bytes32 toPlayer, Item[] memory offeredItems, Item[] memory requestedItems) public {\nbytes32 fromPlayer = addressToEntityKey(_msgSender());\nbytes32 offerId = keccak256(abi.encodePacked(fromPlayer, toPlayer, block.timestamp));\nTradeOffer.set(offerId, TradeOfferData({\nofferId: offerId,\nfromPlayer: fromPlayer,\ntoPlayer: toPlayer,\nofferedItems: offeredItems,\nrequestedItems: requestedItems,\nstatus: \"pending\"\n}));\n}\nfunction acceptTradeOffer(bytes32 offerId) public {\nTradeOfferData memory offer = TradeOffer.get(offerId);\nrequire(offer.toPlayer == addressToEntityKey(_msgSender()), \"Not the recipient\");\nrequire(keccak256(abi.encodePacked(offer.status)) == keccak256(\"pending\"), \"Offer not pending\");\n// Transfer items between players\n// Update inventories and offer status\noffer.status = \"accepted\";\nTradeOffer.set(offerId, offer);\n}\nfunction rejectTradeOffer(bytes32 offerId) public {\nTradeOfferData memory offer = TradeOffer.get(offerId);\nrequire(offer.toPlayer == addressToEntityKey(_msgSender()), \"Not the recipient\");\nrequire(keccak256(abi.encodePacked(offer.status)) == keccak256(\"pending\"), \"Offer not pending\");\noffer.status = \"rejected\";\nTradeOffer.set(offerId, offer);\n}\n}\n```\n3. **Implement Client-Side Logic:**\n- Add UI components for creating, viewing, and managing trade offers.\n- Ensure that the client-side code interacts correctly with the `TradeSystem` contract.\n#### 3. **Feature: Dynamic Quests System**\n- **Objective:** Introduce a dynamic quests system where players can receive and complete quests.\n- **Steps:**\n1. **Define New Schemas:**\n- Add tables for quests and player quest progress in `mud.config.ts`.\n```typescript\nQuest: {\nschema: {\nquestId: \"bytes32\",\ntitle: \"string\",\ndescription: \"string\",\nreward: \"Item[]\",\nstatus: \"string\", // \"available\", \"completed\"\n},\nkey: [\"questId\"],\n},\nPlayerQuest: {\nschema: {\nplayerId: \"bytes32\",\nquestId: \"bytes32\",\nprogress: \"uint256\",\nstatus: \"string\", // \"in-progress\", \"completed\"\n},\nkey: [\"playerId\", \"questId\"],\n},\n```\n2. **Create Quest System Contract:**\n- Implement a new contract `QuestSystem.sol` to manage quests.\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport { System } from \"@latticexyz/world/src/System.sol\";\nimport { Quest, QuestData, PlayerQuest, PlayerQuestData, Inventory, InventoryData } from \"../codegen/index.sol\";\nimport { addressToEntityKey } from \"../addressToEntityKey.sol\";\ncontract QuestSystem is System {\nfunction startQuest(bytes32 questId) public {\nbytes32 playerId = addressToEntityKey(_msgSender());\nPlayerQuest.set(playerId, questId, PlayerQuestData({\nplayerId: playerId,\nquestId: questId,\nprogress: 0,\nstatus: \"in-progress\"\n}));\n}\nfunction completeQuest(bytes32 questId) public {\nbytes32 playerId = addressToEntityKey(_msgSender());\nPlayerQuestData memory playerQuest = PlayerQuest.get(playerId, questId);\nrequire(keccak256(abi.encodePacked(playerQuest.status)) == keccak256(\"in-progress\"), \"Quest not in progress\");\n// Update player quest progress and status\nplayerQuest.status = \"completed\";\nPlayerQuest.set(playerId, questId, playerQuest);\n// Grant rewards to player\nQuestData memory quest = Quest.get(questId);\nInventoryData memory inventory = Inventory.get(playerId);\nfor (uint i = 0; i < quest.reward.length; i++) {\ninventory.items.push(quest.reward[i]);\n}\nInventory.set(playerId, inventory);\n}\n}\n```\n3. **Implement Client-Side Logic:**\n- Add UI components for displaying available quests, tracking quest progress, and claiming rewards.\n- Ensure that the client-side code interacts correctly with the `QuestSystem` contract.\n### Summary\nBy following this action plan, you will be able to implement enhanced inventory management, a player trading system, and a dynamic quests system using the framework described in your notes. Each feature involves updating the schema definitions, implementing new or modified Solidity contracts, and adding corresponding client-side logic to ensure a seamless user experience.","x":-1280,"y":-1760,"width":400,"height":600,"color":"6"},
		{"id":"acd837cb2c39d9c3","type":"text","text":"### Action Plan for Adding Trading and Dynamic Quest Components\n\n1. **Identify and Define Schemas:**\n   - Determine the necessary data structures for Trading and Dynamic Quests.\n   - Define schemas for tables such as `TradeRequest`, `TradeOffer`, `Quest`, `QuestStatus`, etc.\n\n2. **Update Configuration:**\n   - Adjust `mud.config.ts` to include new tables for Trading and Dynamic Quests.\n\n3. **Implement Business Logic:**\n   - Develop the smart contract logic for trading between entities (e.g., sending a trade request, accepting/canceling trades).\n   - Implement dynamic quest logic, such as generating quests, tracking status, and rewarding participants.\n\n4. **Generate Code:**\n   - Utilize `tablegen` CLI to auto-generate table libraries based on the updated configuration.\n\n5. **Testing and Validation:**\n   - Write tests to ensure the correctness of the trading and quest logic.\n   - Validate that the new table structures are correctly storing and retrieving data.\n\n### Updated `mud.config.ts`\n\nHere's how the updated `mud.config.ts` might look:\n\n```typescript\nimport { defineConfig } from \"mud/config\";\n\nexport default defineConfig({\n  // Existing configurations\n\n  // Define new schemas for Trading and Dynamic Quests\n  schemas: {\n    TradeRequest: {\n      requestId: \"bytes32\",\n      requester: \"address\",\n      requestedItem: \"uint256\",\n      quantityRequested: \"uint32\",\n      status: \"uint8\", // 0: Pending, 1: Accepted, 2: Canceled\n    },\n    TradeOffer: {\n      offerId: \"bytes32\",\n      requestId: \"bytes32\",\n      offerer: \"address\",\n      offeredItem: \"uint256\",\n      quantityOffered: \"uint32\",\n    },\n    Quest: {\n      questId: \"bytes32\",\n      questName: \"string\",\n      description: \"string\",\n      reward: \"uint256\",\n      isActive: \"bool\",\n    },\n    QuestStatus: {\n      questId: \"bytes32\",\n      participant: \"address\",\n      status: \"uint8\", // 0: In Progress, 1: Completed, 2: Failed\n    },\n  },\n\n  // Define keys for the new tables\n  keys: {\n    TradeRequest: [\"requestId\"],\n    TradeOffer: [\"offerId\"],\n    Quest: [\"questId\"],\n    QuestStatus: [\"questId\", \"participant\"],\n  },\n\n  // Additional tables for the newly defined schemas\n  tables: {\n    TradeRequest: {\n      schema: {\n        requestId: \"bytes32\",\n        requester: \"address\",\n        requestedItem: \"uint256\",\n        quantityRequested: \"uint32\",\n        status: \"uint8\",\n      },\n      key: [\"requestId\"],\n    },\n    TradeOffer: {\n      schema: {\n        offerId: \"bytes32\",\n        requestId: \"bytes32\",\n        offerer: \"address\",\n        offeredItem: \"uint256\",\n        quantityOffered: \"uint32\",\n      },\n      key: [\"offerId\"],\n    },\n    Quest: {\n      schema: {\n        questId: \"bytes32\",\n        questName: \"string\",\n        description: \"string\",\n        reward: \"uint256\",\n        isActive: \"bool\",\n      },\n      key: [\"questId\"],\n    },\n    QuestStatus: {\n      schema: {\n        questId: \"bytes32\",\n        participant: \"address\",\n        status: \"uint8\",\n      },\n      key: [\"questId\", \"participant\"],\n    },\n  },\n\n  // Additional configuration options...\n});\n```\n\n### Description:\n1. **Schemas**:\n   - `TradeRequest`: Stores information about trade requests.\n   - `TradeOffer`: Stores information about trade offers associated with trade requests.\n   - `Quest`: Stores information about different quests available in the game.\n   - `QuestStatus`: Tracks the status of quests for different participants.\n\n2. **Keys**:\n   - `TradeRequest`, `TradeOffer`, `Quest`, and `QuestStatus`: Defined with appropriate primary keys to uniquely identify each record.\n\n3. **Tables**:\n   - Defines the structure of tables to match the schemas and keys.\n\n4. **Additional Configuration**:\n   - Any other configuration required by the game logic.\n\n### Next Steps:\n1. **Generate Table Libraries**:\n   - Run the `tablegen` CLI to generate the corresponding table libraries.\n\n2. **Implement Business Logic**:\n   - Implement contracts or modules to handle trading and quest logic.\n\n3. **Testing**:\n   - Write comprehensive tests to validate the trading and dynamic quests functionalities.\n\nThis configuration provides a systematic approach to adding new functionalities for trading and dynamic quests in the MUD environment.","x":-2120,"y":-640,"width":695,"height":1552,"color":"6"},
		{"id":"acb07a67fe5ca776","type":"text","text":"# Current mud.config.ts\n```ts\nimport { defineWorld } from \"@latticexyz/world\";\n\n// Define enums for better type safety and readability\nconst EntityType = [\"Player\"];\n\nexport default defineWorld({\n  enums: {\n    EntityType,\n  },\n  tables: {\n    Player: {\n      schema: {\n        id: \"bytes32\",\n        x: \"int32\",\n        y: \"int32\",\n        health: \"uint32\",\n        name: \"string\",\n      },\n      key: [\"id\"],\n    },\n    Lore: {\n      schema: {\n        id: \"bytes32\",\n        alignment: \"string\",\n        backstory: \"string\",\n        currentQuest: \"string\",\n      },\n      key: [\"id\"],\n    },\n    Inventory: {\n      schema: {\n        ownerId: \"bytes32\",\n        itemIds: \"uint8[]\", // Changed to bytes32[] for dynamic length\n      },\n      key: [\"ownerId\"],\n    },\n    Item: {\n      schema: {\n        itemId: \"bytes8\", // Changed to bytes32 for a more consistent key type\n        itemCount: \"uint256\",\n        itemName: \"string\",\n      },\n      key: [\"itemId\"],\n    },\n  },\n  deploy: {\n    upgradeableWorldImplementation: true,\n  },\n});\n```\n","x":-1718,"y":-1240,"width":368,"height":480,"color":"4"},
		{"id":"9cf2240d4adad5da","type":"text","text":"### Updated `mud.config.ts`\n\nGiven your current setup with tables for `Player`, `Lore`, `Inventory`, and `Item`, here is an updated version of `mud.config.ts` that includes the new configurations for Trading and Dynamic Quests:\n\n```typescript\nimport { defineWorld } from \"@latticexyz/world\";\n\n// Define enums for better type safety and readability\nconst EntityType = [\"Player\"];\n\nexport default defineWorld({\n  enums: {\n    EntityType,\n  },\n  tables: {\n    Player: {\n      schema: {\n        id: \"bytes32\",\n        x: \"int32\",\n        y: \"int32\",\n        health: \"uint32\",\n        name: \"string\",\n      },\n      key: [\"id\"],\n    },\n    Lore: {\n      schema: {\n        id: \"bytes32\",\n        alignment: \"string\",\n        backstory: \"string\",\n        currentQuest: \"string\",\n      },\n      key: [\"id\"],\n    },\n    Inventory: {\n      schema: {\n        ownerId: \"bytes32\",\n        itemIds: \"uint8[]\", // Changed to bytes32[] for dynamic length\n      },\n      key: [\"ownerId\"],\n    },\n    Item: {\n      schema: {\n        itemId: \"bytes8\", // Changed to bytes32 for a more consistent key type\n        itemCount: \"uint256\",\n        itemName: \"string\",\n      },\n      key: [\"itemId\"],\n    },\n    // New tables for Trading and Dynamic Quests\n    TradeRequest: {\n      schema: {\n        requestId: \"bytes32\",\n        requester: \"address\",\n        requestedItem: \"uint256\",\n        quantityRequested: \"uint32\",\n        status: \"uint8\", // 0: Pending, 1: Accepted, 2: Canceled\n      },\n      key: [\"requestId\"],\n    },\n    TradeOffer: {\n      schema: {\n        offerId: \"bytes32\",\n        requestId: \"bytes32\",\n        offerer: \"address\",\n        offeredItem: \"uint256\",\n        quantityOffered: \"uint32\",\n      },\n      key: [\"offerId\"],\n    },\n    Quest: {\n      schema: {\n        questId: \"bytes32\",\n        questName: \"string\",\n        description: \"string\",\n        reward: \"uint256\",\n        isActive: \"bool\",\n      },\n      key: [\"questId\"],\n    },\n    QuestStatus: {\n      schema: {\n        questId: \"bytes32\",\n        participant: \"address\",\n        status: \"uint8\", // 0: In Progress, 1: Completed, 2: Failed\n      },\n      key: [\"questId\", \"participant\"],\n    },\n  },\n  deploy: {\n    upgradeableWorldImplementation: true,\n  },\n});\n```\n\n### Explanation of the Changes:\n\n1. **Existing Schemas:**\n   - No changes were made to `Player`, `Lore`, `Inventory`, and `Item` tables.\n   \n2. **New Schemas:**\n   - **TradeRequest**: Table schema to store trade requests made by players.\n     - `requestId`: Unique identifier for the trade request.\n     - `requester`: Address of the player who made the request.\n     - `requestedItem`: ID of the item being requested.\n     - `quantityRequested`: Quantity of the item being requested.\n     - `status`: Status of the trade request (Pending, Accepted, Canceled).\n\n   - **TradeOffer**: Table schema to store offers made in response to trade requests.\n     - `offerId`: Unique identifier for the trade offer.\n     - `requestId`: ID of the associated trade request.\n     - `offerer`: Address of the player making the offer.\n     - `offeredItem`: ID of the item being offered.\n     - `quantityOffered`: Quantity of the item being offered.\n\n   - **Quest**: Table schema to store quests available in the game.\n     - `questId`: Unique identifier for the quest.\n     - `questName`: Name of the quest.\n     - `description`: Detailed description of the quest.\n     - `reward`: Reward for completing the quest.\n     - `isActive`: Indicates whether the quest is currently active.\n\n   - **QuestStatus**: Table schema to track the status of quests for different participants.\n     - `questId`: ID of the quest.\n     - `participant`: Address of the player participating in the quest.\n     - `status`: Status of the quest for the participant (In Progress, Completed, Failed).\n\n3. **Configuration Adjustments:**\n   - Integrated the new tables into the existing configuration, ensuring the new schemas are properly defined and keys are set as per the data access requirements.\n\n### Next Steps:\n\n1. **Generate Table Libraries:**\n   - Run `tablegen` CLI to generate the corresponding table libraries based on the updated configuration.\n\n2. **Implement Smart Contract Logic:**\n   - Develop smart contracts or modules to handle the business logic for trading and dynamic quests.\n\n3. **Testing and Validation:**\n   - Write tests to verify the correct functionality of the newly added trading and quest systems.\n   - Ensure the correct storage and retrieval of data within the new tables. \n\nThis setup will help ensure that the new trading and dynamic quest functionalities are well-integrated into your MUD-based game environment.","x":-1280,"y":-1502,"width":880,"height":1638,"color":"6"}
	],
	"edges":[
		{"id":"54adf3d753b55261","fromNode":"cfdb92b92c39180e","fromSide":"left","toNode":"8a14e06e456373e1","toSide":"top"},
		{"id":"34f33ddb852fa626","fromNode":"b3f0de196305c8f3","fromSide":"bottom","toNode":"8a14e06e456373e1","toSide":"top"},
		{"id":"afc592544053d0ec","fromNode":"855f1a7fcfbd979e","fromSide":"bottom","toNode":"8a14e06e456373e1","toSide":"top"},
		{"id":"912997d39bf2115c","fromNode":"8a14e06e456373e1","fromSide":"bottom","toNode":"acd837cb2c39d9c3","toSide":"top"},
		{"id":"6d05531a9a5373bd","fromNode":"8a14e06e456373e1","fromSide":"right","toNode":"acb07a67fe5ca776","toSide":"left"},
		{"id":"ceea10221f027bdb","fromNode":"acb07a67fe5ca776","fromSide":"right","toNode":"9cf2240d4adad5da","toSide":"top"}
	]
}