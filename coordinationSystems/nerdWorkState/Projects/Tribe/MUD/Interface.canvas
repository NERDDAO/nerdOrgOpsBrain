{
	"nodes":[
		{"id":"89065b61bf6418f2","type":"group","x":-2640,"y":-2880,"width":4596,"height":4087,"label":"Untitled group"},
		{"id":"19d3e6ef2b62f8a5","type":"text","text":"```ts\nimport React from \"react\";\nimport PlayerInput from \"../PlayerInput\";\nimport PlayerList from \"../PlayerList\";\nimport { useMUD } from \"./MUDContext\";\n\nconst GameBoard = () => {\n  const {\n    network: { useStore, tables },\n  } = useMUD();\n\n  const records = useStore(state => Object.values(state.getRecords(tables.Player)));\n\n  return (\n    <div className=\"container flex flex-row mx-auto w-full h-full\">\n      <PlayerInput />\n      <PlayerList players={records} />\n    </div>\n  );\n};\n\nexport default GameBoard;\n```","x":838,"y":263,"width":703,"height":540,"color":"6"},
		{"id":"f50f7696e8a09c60","type":"text","text":"```ts\nimport React from \"react\";\nimport Image from \"next/image\";\nimport LoreDisplay from \"./LoreDisplay\";\nimport { pixelArt } from \"@dicebear/collection\";\nimport { createAvatar } from \"@dicebear/core\";\n\nconst PlayerList = (props: { players: any }) => {\n  const { players } = props;\n  return (\n    <div className=\"p-5 bg-gray-100 rounded-lg shadow-md overflow-scroll max-h-svh flex justify-items-end\">\n      <h2 className=\"mb-5 text-2xl font-bold text-gray-800\">Players:</h2>\n      <ul>\n        {players.map(player => {\n          const avatarSvg = createAvatar(pixelArt, {\n            seed: player.value.name,\n            dataUri: true,\n          });\n          return (\n            <li key={player.id} className=\"flex p-4 mb-4 bg-white rounded-lg shadow-sm hover:bg-gray-50\">\n              <div className=\"flex-1\">\n                <h3 className=\"text-xl font-semibold text-blue-600\">{player.value.name}</h3>\n                <p className=\"mt-2 text-gray-700\">\n                  <strong>Coordinates:</strong> (x: {player.value.x}, y: {player.value.y})\n                </p>\n                <p className=\"mt-1 text-gray-700\">\n                  <strong>Health:</strong> {player.value.health}\n                </p>\n                <LoreDisplay entityId={player.key.id} />\n              </div>\n              <div className=\"ml-4\">\n                <Image\n                  className=\"w-12 h-12 rounded-full\"\n                  src={avatarSvg.toDataUriSync()}\n                  alt={`${player.value.name}'s avatar`}\n                  width={48}\n                  height={48}\n                />\n              </div>\n            </li>\n          );\n        })}\n      </ul>\n    </div>\n  );\n};\n```","x":852,"y":136,"width":281,"height":254,"color":"6"},
		{"id":"7eb3059beb3e14dd","type":"text","text":"```ts\nimport React, { useState } from \"react\";\nimport { useMUD } from \"./mud/MUDContext\";\nimport { usePlayerStore } from \"~~/services/store/playerStore\";\n\nconst PlayerInput = () => {\n  const playerName = usePlayerStore(state => state.playerName);\n  const setPlayerName = usePlayerStore(state => state.setPlayerName);\n  const { lore, setLore } = usePlayerStore();\n\n  const {\n    systemCalls: { spawn },\n  } = useMUD();\n\n  return (\n    <div className=\"p-2 form-control\">\n      <h2 className=\"mb-5 text-2xl font-bold text-gray-800\">Edit Lore:</h2>\n      <div>\n        <label className=\"label\">Player Name</label>\n        <input\n          className=\"input\"\n          type=\"text\"\n          value={playerName}\n          onChange={e => setPlayerName(e.target.value)}\n          placeholder=\"Enter player name\"\n        />\n      </div>\n      <div>\n        <label className=\"label\">Alignment:</label>\n        <input\n          className=\"input\"\n          value={lore.alignment}\n          onChange={e => setLore({ ...lore, alignment: e.target.value })}\n        />\n      </div>\n      <div>\n        <label className=\"label\">Backstory:</label>\n        <textarea\n          className=\"input\"\n          value={lore.backstory}\n          onChange={e => setLore({ ...lore, backstory: e.target.value })}\n        />\n      </div>\n      <div>\n        <label className=\"label\">Current Quest:</label>\n        <input\n          className=\"input\"\n          value={lore.currentQuest}\n          onChange={e => setLore({ ...lore, currentQuest: e.target.value })}\n        />\n      </div>\n\n      <button className=\"btn\" onClick={spawn}>\n        spawn\n      </button>\n    </div>\n  );\n};\n\nexport default PlayerInput;\n```","x":896,"y":-101,"width":430,"height":460,"color":"6"},
		{"id":"f1e238c55c896f33","type":"text","text":"```ts\nimport React from \"react\";\nimport { useMUD } from \"./mud/MUDContext\";\n\nconst LoreDisplay = ({ entityId }) => {\n  const {\n    network: { playerEntity, useStore, tables },\n  } = useMUD();\n\n  const lore = useStore(state => Object.values(state.getRecords(tables.Lore)));\n  console.log(\"All Lore:\", lore); // Log all lore objects\n  console.log(\"Entity ID:\", entityId); // Log the entityId being searched for\n\n  const myLore = lore.find(item => item.key.id === entityId);\n  console.log(\"Found Lore:\", myLore); // Log the found lore object\n\n  if (!myLore) return <div>No lore available for this entity.</div>;\n\n  return (\n    <div className=\"p-5 bg-gray-100 rounded-lg shadow-md\">\n      <h2 className=\"mb-5 text-2xl font-bold text-gray-800\">Lore:</h2>\n      <p>\n        <strong>Alignment:</strong> {myLore.value.alignment}\n      </p>\n      <p>\n        <strong>Backstory:</strong> {myLore.value.backstory}\n      </p>\n      <p>\n        <strong>Current Quest:</strong> {myLore.value.currentQuest}\n      </p>\n    </div>\n  );\n};\n```","x":896,"y":171,"width":687,"height":577,"color":"6"},
		{"id":"c4a01e82b9d060b9","type":"text","text":"To update the interface to handle the new calls for trading and dynamic quests, you need to adjust both the frontend UI (e.g., React components) and possibly the backend (e.g., smart contract interactions). Below is an example of how you could update your React components to include trading and dynamic quest functionalities.\n\n### React Components\n\nLet's assume you have a component structure that includes a player dashboard or similar interface where you can display quests, inventory, etc. We'll add buttons and forms for creating quests, completing quests, and trading items.\n\n#### QuestComponent.tsx\n\n```tsx\nimport React, { useState } from \"react\";\nimport { SystemCalls } from \"./createSystemCalls\";\n\ninterface Props {\n  systemCalls: SystemCalls;\n}\n\nexport const QuestComponent: React.FC<Props> = ({ systemCalls }) => {\n  const [name, setName] = useState(\"\");\n  const [description, setDescription] = useState(\"\");\n  const [reward, setReward] = useState<number>();\n  const [completeQuestId, setCompleteQuestId] = useState(\"\");\n\n  const handleCreateQuest = async () => {\n    if (!name || !reward) {\n      alert(\"Name and reward are required\");\n      return;\n    }\n    await systemCalls.createQuest(name, description, reward);\n  };\n\n  const handleCompleteQuest = async () => {\n    if (!completeQuestId) {\n      alert(\"Quest ID is required\");\n      return;\n    }\n    await systemCalls.completeQuest(completeQuestId);\n  };\n\n  return (\n    <div>\n      <h2>Create Quest</h2>\n      <input\n        type=\"text\"\n        placeholder=\"Quest Name\"\n        value={name}\n        onChange={(e) => setName(e.target.value)}\n      />\n      <input\n        type=\"text\"\n        placeholder=\"Description\"\n        value={description}\n        onChange={(e) => setDescription(e.target.value)}\n      />\n      <input\n        type=\"number\"\n        placeholder=\"Reward\"\n        value={reward}\n        onChange={(e) => setReward(Number(e.target.value))}\n      />\n      <button onClick={handleCreateQuest}>Create Quest</button>\n\n      <h2>Complete Quest</h2>\n      <input\n        type=\"text\"\n        placeholder=\"Quest ID\"\n        value={completeQuestId}\n        onChange={(e) => setCompleteQuestId(e.target.value)}\n      />\n      <button onClick={handleCompleteQuest}>Complete Quest</button>\n    </div>\n  );\n};\n```\n\n#### TradingComponent.tsx\n\n```tsx\nimport React, { useState } from \"react\";\nimport { SystemCalls } from \"./createSystemCalls\";\n\ninterface Props {\n  systemCalls: SystemCalls;\n}\n\nexport const TradingComponent: React.FC<Props> = ({ systemCalls }) => {\n  const [from, setFrom] = useState(\"\");\n  const [to, setTo] = useState(\"\");\n  const [itemId, setItemId] = useState(\"\");\n\n  const handleTradeItem = async () => {\n    if (!from || !to || !itemId) {\n      alert(\"All fields are required\");\n      return;\n    }\n    await systemCalls.tradeItem(from, to, itemId);\n  };\n\n  return (\n    <div>\n      <h2>Trade Item</h2>\n      <input\n        type=\"text\"\n        placeholder=\"From user ID\"\n        value={from}\n        onChange={(e) => setFrom(e.target.value)}\n      />\n      <input\n        type=\"text\"\n        placeholder=\"To user ID\"\n        value={to}\n        onChange={(e) => setTo(e.target.value)}\n      />\n      <input\n        type=\"text\"\n        placeholder=\"Item ID\"\n        value={itemId}\n        onChange={(e) => setItemId(e.target.value)}\n      />\n      <button onClick={handleTradeItem}>Trade Item</button>\n    </div>\n  );\n};\n```\n\n#### Main Dashboard or App Component\n\n```tsx\nimport React from \"react\";\nimport { QuestComponent } from \"./QuestComponent\";\nimport { TradingComponent } from \"./TradingComponent\";\nimport { SystemCalls } from \"./createSystemCalls\";\n\ninterface Props {\n  systemCalls: SystemCalls;\n}\n\nexport const Dashboard: React.FC<Props> = ({ systemCalls }) => {\n  return (\n    <div>\n      <h1>Player Dashboard</h1>\n      <QuestComponent systemCalls={systemCalls} />\n      <TradingComponent systemCalls={systemCalls} />\n    </div>\n  );\n};\n```\n\n### Integration\n\nMake sure your `App` component or wherever you setup your main component tree has access to the `systemCalls` and passes it down to the `Dashboard`.\n\n```tsx\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Dashboard } from \"./Dashboard\";\nimport { createSystemCalls } from \"./createSystemCalls\";\nimport { setupNetwork } from \"./setupNetwork\"; \nimport { createClientComponents } from \"./createClientComponents\"; \n\nconst networkSetup = setupNetwork();\nconst clientComponents = createClientComponents(networkSetup);\nconst systemCalls = createSystemCalls(networkSetup, clientComponents);\n\nReactDOM.render(\n  <React.StrictMode>\n    <Dashboard systemCalls={systemCalls} />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n```\n\nThis code showcases a simple interface for handling the creation and completion of quests as well as trading items between players. The form validations and button actions trigger the appropriate calls to the blockchain smart contracts using the `systemCalls` you have defined previously.\n\n### Points to Consider:\n\n1. **Error Handling and User Feedback**: Ensure that user actions trigger proper feedback (error/success messages) using the `toast` notifications as shown in the `handleTransaction` helper method.\n2. **State Management**: Depending on your app's complexity, managing the state of quests, player info, and inventory might require additional logic or even using a state management library.\n3. **Styles**: For better user experience, consider adding styles and possibly animations to enhance the UI interactions.\n\nThis setup should give you a functional and interactive interface for players to interact with dynamic quests and trading items in a structured manner, extending the gameplay features of your application.","x":-2282,"y":-328,"width":1200,"height":1182,"color":"6"},
		{"id":"4f47139143db013b","type":"text","text":"To implement dynamic quest and trading functionality, you need to define the operations to create quests, complete quests, and trade items. Hereâ€™s how you could extend the system calls with these functionalities:\n\n### Define Quest and Trading Functions\n\n1. **`createQuest`** - Create a new quest.\n2. **`completeQuest`** - Mark a quest as complete.\n3. **`tradeItem`** - Facilitate trading of items between two players.\n\nHere's an example of how to add these functions:\n\n```ts\nimport { ClientComponents } from \"./createClientComponents\";\nimport { SetupNetworkResult } from \"./setupNetwork\";\nimport { getComponentValue } from \"@latticexyz/recs\";\nimport { uuid } from \"@latticexyz/utils\";\nimport { toast } from \"react-hot-toast\";\nimport { usePlayerStore } from \"~~/services/store/playerStore\";\n\nexport type SystemCalls = ReturnType<typeof createSystemCalls>;\n\nexport function createSystemCalls(\n  { playerEntity, worldContract, waitForTransaction }: SetupNetworkResult,\n  { Player, Lore, Inventory, Item, Quest, Trading }: ClientComponents\n) {\n  \n  const handleTransaction = async (\n    transactionFn: () => Promise<any>,\n    loadingMessage: string,\n    successMessage: string,\n    errorMessage: string\n  ) => {\n    toast.loading(loadingMessage);\n\n    try {\n      const tx = await transactionFn();\n      await waitForTransaction(tx);\n      toast.success(successMessage);\n    } catch (error) {\n      console.error(\"Transaction failed:\", error);\n      toast.error(errorMessage);\n    } finally {\n      toast.dismiss();\n    }\n  };\n\n  const spawn = async () => {\n    if (!playerEntity) {\n      throw new Error(\"no player\");\n    }\n\n    const canSpawn = getComponentValue(Player, playerEntity)?.value !== true;\n    const playerName = usePlayerStore.getState().playerName;\n    const lore = usePlayerStore.getState().lore;\n\n    if (!canSpawn) {\n      throw new Error(\"already spawned\");\n    }\n\n    const playerId = uuid();\n    Player.addOverride(playerId, {\n      entity: playerEntity,\n      value: { value: true },\n    });\n\n    toast.loading(\"Spawning player...\");\n\n    try {\n      const args = {\n        x: 0,\n        y: 0,\n        health: 100,\n        name: playerName,\n      };\n      const tx = await worldContract.write.spawnPlayer([args, lore]);\n      await waitForTransaction(tx);\n      toast.success(`Player spawned! ${playerName}`);\n    } catch (error) {\n      console.error(\"Spawn transaction failed:\", error);\n      toast.error(\"Failed to spawn player.\");\n    } finally {\n      setTimeout(() => {\n        Player.removeOverride(playerId);\n        toast.dismiss();\n      }, 1000);\n    }\n  };\n\n  const addItemToInventory = async () => {\n    await handleTransaction(\n      () => worldContract.write.addItemToInventory([1]),\n      \"Adding item...\",\n      \"Item added!\",\n      \"Failed to add item.\"\n    );\n  };\n\n  const removeItemFromInventory = async (ownerId: string, itemId: string) => {\n    await handleTransaction(\n      () => worldContract.write.removeItemFromInventory([ownerId, itemId]),\n      \"Removing item...\",\n      \"Item removed!\",\n      \"Failed to remove item.\"\n    );\n  };\n\n  const createQuest = async (name: string, description: string, reward: number) => {\n    await handleTransaction(\n      () => worldContract.write.createQuest([name, description, reward]),\n      \"Creating quest...\",\n      \"Quest created!\",\n      \"Failed to create quest.\"\n    );\n  };\n\n  const completeQuest = async (questId: string) => {\n    await handleTransaction(\n      () => worldContract.write.completeQuest([questId]),\n      \"Completing quest...\",\n      \"Quest completed!\",\n      \"Failed to complete quest.\"\n    );\n  };\n\n  const tradeItem = async (from: string, to: string, itemId: string) => {\n    await handleTransaction(\n      () => worldContract.write.tradeItem([from, to, itemId]),\n      \"Trading item...\",\n      \"Item traded!\",\n      \"Failed to trade item.\"\n    );\n  };\n\n  return {\n    spawn,\n    addItemToInventory,\n    removeItemFromInventory,\n    createQuest,\n    completeQuest,\n    tradeItem,\n  };\n}\n```\n\n### Key Additions:\n\n1. **`createQuest`**:\n    - Initiates a transaction to create a new quest using the `worldContract`.\n    - Waits for the transaction to be completed and displays appropriate toast notifications.\n\n2. **`completeQuest`**:\n    - Marks a quest as completed using the `worldContract`.\n    - Handles transaction completion and displays toast notifications.\n\n3. **`tradeItem`**:\n    - Facilitates item trading between two players.\n    - Uses `worldContract` for initiating the trade transaction and handles success, fail cases with toast notifications.\n\n### Integration with Smart Contracts\nMake sure that the smart contract on the blockchain has these functions:\n- `spawnPlayer`\n- `addItemToInventory`\n- `removeItemFromInventory`\n- `createQuest`\n- `completeQuest`\n- `tradeItem`\n\nEach of these should correctly receive and handle the parameters and perform the actions as implemented above. This design leverages a simplistic approach by collating common code into helper methods and making each function more straightforward to reason about and maintain.\n\nFeel free to adapt parameters based on the actual contract requirements and data structures in use. If more specific state management or other operations are required, each function can be by extending the helper function as needed.","x":-2423,"y":-2440,"width":1800,"height":1090,"color":"6"},
		{"id":"ea14b13115f53033","type":"text","text":"Implementing system contracts for Trading and dynamic quests will require careful consideration of security, state storage, and interactions between different entities. Below are basic implementations for TradingSystem and DynamicQuestSystem contracts.\n\n### Trading System\n```ts\n \n```\n\n### Dynamic Quests System\n```ts\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { System } from \"@latticexyz/world/src/System.sol\";\nimport { Inventory, Item, ItemData, Quest, QuestData } from \"../codegen/index.sol\";\nimport { addressToEntityKey } from \"../addressToEntityKey.sol\";\n\ncontract DynamicQuestSystem is System {\n    uint public questCounter;\n\n    event QuestCreated(uint questId, string questName, string questDescription, bytes8 rewardItemId);\n    event QuestCompleted(uint questId, address player);\n\n    function createQuest(string memory questName, string memory questDescription, bytes8 rewardItemId) public {\n        questCounter++;\n        Quest.set(questCounter, QuestData({name: questName, description: questDescription, rewardItemId: rewardItemId, isActive: true}));\n\n        emit QuestCreated(questCounter, questName, questDescription, rewardItemId);\n    }\n\n    function completeQuest(uint questId) public {\n        QuestData memory questData = Quest.get(questId);\n        require(questData.isActive, \"Quest is not active\");\n\n        bytes32 playerId = addressToEntityKey(msg.sender);\n        _rewardItemToPlayer(playerId, questData.rewardItemId);\n\n        // Mark quest as completed\n        Quest.set(questId, QuestData({name: questData.name, description: questData.description, rewardItemId: questData.rewardItemId, isActive: false}));\n\n        emit QuestCompleted(questId, msg.sender);\n    }\n\n    function _rewardItemToPlayer(bytes32 playerId, bytes8 rewardItemId) internal {\n        Inventory.pushItemIds(playerId, rewardItemId);\n        Item.set(rewardItemId, ItemData({ itemCount: 1, itemName: \"Reward Item\" })); // Presume reward item data available\n    }\n}\n```\n\n### Notes:\n- These implementations assume the existence of respective getter and setter methods in Inventory, Item, and Quest contracts.\n- You may need to tailor the code according to the actual structure and methods of your `Inventory`, `Item`, and `Quest` entities.\n- Proper security checks should be enforced to ensure that only authorized actions are allowed.\n- The dynamic quest system adds and completes quests, rewarding players upon completion. It assumes a basic mechanism for item management and quest tracking.\n- You should also ensure proper error handling and edge cases checks for production-level contracts, such as non-existent item IDs, overflow checks, and correct state transitions.","x":-480,"y":-2307,"width":1299,"height":1180,"color":"6"},
		{"id":"8cf7985ec3d83205","type":"text","text":"### Action Plan for Adding Trading and Dynamic Quest Components\n\n1. **Identify and Define Schemas:**\n   - Determine the necessary data structures for Trading and Dynamic Quests.\n   - Define schemas for tables such as `TradeRequest`, `TradeOffer`, `Quest`, `QuestStatus`, etc.\n\n2. **Update Configuration:**\n   - Adjust `mud.config.ts` to include new tables for Trading and Dynamic Quests.\n\n3. **Implement Business Logic:**\n   - Develop the smart contract logic for trading between entities (e.g., sending a trade request, accepting/canceling trades).\n   - Implement dynamic quest logic, such as generating quests, tracking status, and rewarding participants.\n\n4. **Generate Code:**\n   - Utilize `tablegen` CLI to auto-generate table libraries based on the updated configuration.\n\n5. **Testing and Validation:**\n   - Write tests to ensure the correctness of the trading and quest logic.\n   - Validate that the new table structures are correctly storing and retrieving data.\n\n### Updated `mud.config.ts`\n\nHere's how the updated `mud.config.ts` might look:\n\n```typescript\nimport { defineConfig } from \"mud/config\";\n\nexport default defineConfig({\n  // Existing configurations\n\n  // Define new schemas for Trading and Dynamic Quests\n  schemas: {\n    TradeRequest: {\n      requestId: \"bytes32\",\n      requester: \"address\",\n      requestedItem: \"uint256\",\n      quantityRequested: \"uint32\",\n      status: \"uint8\", // 0: Pending, 1: Accepted, 2: Canceled\n    },\n    TradeOffer: {\n      offerId: \"bytes32\",\n      requestId: \"bytes32\",\n      offerer: \"address\",\n      offeredItem: \"uint256\",\n      quantityOffered: \"uint32\",\n    },\n    Quest: {\n      questId: \"bytes32\",\n      questName: \"string\",\n      description: \"string\",\n      reward: \"uint256\",\n      isActive: \"bool\",\n    },\n    QuestStatus: {\n      questId: \"bytes32\",\n      participant: \"address\",\n      status: \"uint8\", // 0: In Progress, 1: Completed, 2: Failed\n    },\n  },\n\n  // Define keys for the new tables\n  keys: {\n    TradeRequest: [\"requestId\"],\n    TradeOffer: [\"offerId\"],\n    Quest: [\"questId\"],\n    QuestStatus: [\"questId\", \"participant\"],\n  },\n\n  // Additional tables for the newly defined schemas\n  tables: {\n    TradeRequest: {\n      schema: {\n        requestId: \"bytes32\",\n        requester: \"address\",\n        requestedItem: \"uint256\",\n        quantityRequested: \"uint32\",\n        status: \"uint8\",\n      },\n      key: [\"requestId\"],\n    },\n    TradeOffer: {\n      schema: {\n        offerId: \"bytes32\",\n        requestId: \"bytes32\",\n        offerer: \"address\",\n        offeredItem: \"uint256\",\n        quantityOffered: \"uint32\",\n      },\n      key: [\"offerId\"],\n    },\n    Quest: {\n      schema: {\n        questId: \"bytes32\",\n        questName: \"string\",\n        description: \"string\",\n        reward: \"uint256\",\n        isActive: \"bool\",\n      },\n      key: [\"questId\"],\n    },\n    QuestStatus: {\n      schema: {\n        questId: \"bytes32\",\n        participant: \"address\",\n        status: \"uint8\",\n      },\n      key: [\"questId\", \"participant\"],\n    },\n  },\n\n  // Additional configuration options...\n});\n```\n\n### Description:\n1. **Schemas**:\n   - `TradeRequest`: Stores information about trade requests.\n   - `TradeOffer`: Stores information about trade offers associated with trade requests.\n   - `Quest`: Stores information about different quests available in the game.\n   - `QuestStatus`: Tracks the status of quests for different participants.\n\n2. **Keys**:\n   - `TradeRequest`, `TradeOffer`, `Quest`, and `QuestStatus`: Defined with appropriate primary keys to uniquely identify each record.\n\n3. **Tables**:\n   - Defines the structure of tables to match the schemas and keys.\n\n4. **Additional Configuration**:\n   - Any other configuration required by the game logic.\n\n### Next Steps:\n1. **Generate Table Libraries**:\n   - Run the `tablegen` CLI to generate the corresponding table libraries.\n\n2. **Implement Business Logic**:\n   - Implement contracts or modules to handle trading and quest logic.\n\n3. **Testing**:\n   - Write comprehensive tests to validate the trading and dynamic quests functionalities.\n\nThis configuration provides a systematic approach to adding new functionalities for trading and dynamic quests in the MUD environment.","x":960,"y":-2320,"width":695,"height":1552,"color":"6"},
		{"id":"c25fb3ad9ed8eb47","type":"text","text":"Update the interface to handle the new calls of trading and dynamic quests","x":-1600,"y":-1263,"width":282,"height":272,"color":"4"}
	],
	"edges":[
		{"id":"66cd41df5a137ff2","fromNode":"7eb3059beb3e14dd","fromSide":"top","toNode":"c25fb3ad9ed8eb47","toSide":"bottom"},
		{"id":"1e5b06fd6fbdf20e","fromNode":"f1e238c55c896f33","fromSide":"top","toNode":"c25fb3ad9ed8eb47","toSide":"bottom"},
		{"id":"46d3dc1daccf68e9","fromNode":"19d3e6ef2b62f8a5","fromSide":"top","toNode":"c25fb3ad9ed8eb47","toSide":"bottom"},
		{"id":"b87b2911594257ee","fromNode":"f50f7696e8a09c60","fromSide":"top","toNode":"c25fb3ad9ed8eb47","toSide":"bottom"},
		{"id":"b9b1db1debd55608","fromNode":"c25fb3ad9ed8eb47","fromSide":"left","toNode":"c4a01e82b9d060b9","toSide":"right"},
		{"id":"67c9707a4364a418","fromNode":"8cf7985ec3d83205","fromSide":"bottom","toNode":"c25fb3ad9ed8eb47","toSide":"right"},
		{"id":"5d0a099065633d75","fromNode":"ea14b13115f53033","fromSide":"bottom","toNode":"c25fb3ad9ed8eb47","toSide":"top"},
		{"id":"153cd05ca3e90670","fromNode":"4f47139143db013b","fromSide":"bottom","toNode":"c25fb3ad9ed8eb47","toSide":"top"}
	]
}