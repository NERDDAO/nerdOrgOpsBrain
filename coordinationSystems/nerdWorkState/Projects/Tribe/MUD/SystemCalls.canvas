{
	"nodes":[
		{"id":"b0663f3075c3030f","type":"group","x":-2298,"y":-1846,"width":4596,"height":3693,"label":"Untitled group"},
		{"id":"5415a6e4c950a6ea","type":"text","text":"\n\n# Systems\n\nOne of the design principles of MUD is to separate the state of the `World` from the business logic. The business logic is implemented in stateless `System` contracts. `System`s are called through the `World`, and call back to the `World` to read and write state from [tables](/world/tables).\n\nDetailed illustration\n\n![Interaction between the World, a System, and a table](https://mud.dev/world/systems/_next/static/media/world-table.39df342f.svg)\n\n1. An account calls a function called `game__myFunc` on the `World`. [This function was registered](/world/function-selectors) by the owner of the `game` namespace and points to the `myFunc` function in one of the `System`s in the `namespace` namespace.\n    \n2. The `World` verifies that access is permitted (for example, because `game:System` is publicly accessible) and if so calls `myFunc` on the `game:System` contract with the provided parameters.\n    \n3. At some point in its execution `myFunc` decides to update the data in the table `game:Items`. As with all other tables, this table is stored in the `World`'s storage. To modify it, `function` calls a function on the `World` contract.\n    \n4. The `World` verifies that access is permitted (by default it would be, because `game:System` has access to the `game` namespace). If so, it modifies the data in the `game:Items` table.\n    \n\nThe `World` serves as a central entry point and forwards calls to systems, which allows it to provide [access control](/world/namespaces-access-control).\n\n## Calling systems[](#calling-systems)\n\nTo call a `System`, you call the `World` in one of these ways:\n\n- If a [function selector for the `System` is registered in the `World`](/world/function-selectors), you can call it via `world.<namespace>__<function>(<arguments>)`.\n- You can use [`call` (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/world/src/World.sol#L333-L345).\n- If you have [the proper delegation](/world/account-delegation) you can use [`callFrom` (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/world/src/World.sol#L347-L388).\n\n### Using `call`[](#using-call)\n\nTo use `call` you create the calldata to send the called `System` and use that as a parameter.\n\nCall.s.sol\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n \nimport { Script } from \"forge-std/Script.sol\";\nimport { console } from \"forge-std/console.sol\";\nimport { StoreSwitch } from \"@latticexyz/store/src/StoreSwitch.sol\";\n \nimport { IWorld } from \"../src/codegen/world/IWorld.sol\";\nimport { Tasks, TasksData } from \"../src/codegen/index.sol\";\n \nimport { ResourceId, WorldResourceIdLib, WorldResourceIdInstance } from \"@latticexyz/world/src/WorldResourceId.sol\";\nimport { RESOURCE_SYSTEM } from \"@latticexyz/world/src/worldResourceTypes.sol\";\n \ncontract Call is Script {\n  function run() external {\n    address worldAddress = 0xC14fBdb7808D9e2a37c1a45b635C8C3fF64a1cc1;\n \n    // Load the private key from the `PRIVATE_KEY` environment variable (in .env)\n    uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\");\n \n    // Start broadcasting transactions from the deployer account\n    vm.startBroadcast(deployerPrivateKey);\n \n    ResourceId systemId = WorldResourceIdLib.encode({ typeId: RESOURCE_SYSTEM, namespace: \"\", name: \"TasksSystem\" });\n \n    bytes memory returnData = IWorld(worldAddress).call(\n      systemId,\n      abi.encodeWithSignature(\"addTask(string)\", \"Test task\")\n    );\n \n    console.log(\"The return value is:\");\n    console.logBytes(returnData);\n \n    vm.stopBroadcast();\n  }\n}\n```\n\nExplanation\n\n```\nimport { ResourceId, WorldResourceIdLib, WorldResourceIdInstance } from \"@latticexyz/world/src/WorldResourceId.sol\";\nimport { RESOURCE_SYSTEM } from \"@latticexyz/world/src/worldResourceTypes.sol\";\n.\n.\n.\nResourceId systemId = WorldResourceIdLib.encode({\n  typeId: RESOURCE_SYSTEM,\n  namespace: \"\",\n  name: \"TasksSystem\"\n});\n```\n\nCreate a `ResourceId` for the `System`.\n\n```\nbytes memory returnData =\n  IWorld(worldAddress).\n    call(systemId, abi.encodeWithSignature(\"addTask(string)\", \"Test task\"));\n```\n\nCall the `System`. The calldata is created using [`abi.encodeWithSignature` (opens in a new tab)](https://docs.soliditylang.org/en/latest/cheatsheet.html#index-1).\n\nThe return data is of type [`bytes memory` (opens in a new tab)](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html#bytes-and-string).\n\n## Writing systems[](#writing-systems)\n\nA `System` should _not_ have any internal state, but store all of it in tables in the `World`. There are several reasons for this:\n\n- It allows a `World` to enforce access controls.\n- It allows the same `System` to be used by multiple `World` contracts.\n- Upgrades are a lot simpler when all the state is centralized outside of the `System` contract.\n\nBecause calls to systems are proxied through the `World`, some message fields don't reflect the original call. Use these substitutes:\n\n|Vanilla Solidity|`System` replacement|\n|---|---|\n|`msg.sender`|`_msgSender()`|\n|`msg.value`|`_msgValue()`|\n\nWhen calling other contracts from a `System`, be aware that if you use `delegatecall` the called contract inherits the `System`'s permissions and can modify data in the `World` on behalf of the `System`.\n\n### Calling one `System` from another[](#calling-one-system-from-another)\n\nThere are two ways to call one `System` from another one.\n\n|Call type|`call` to the `World`|`delegatecall` directly to the `System`|\n|---|---|---|\n|Permissions|those of the called `System`|those of the calling `System`|\n|`_msgSender()`|calling `System` (unless you can use `callFrom`, which is only available when the user [delegates](/world/account-delegation) to your `System`)|can use [`WorldContextProvider` (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/world/src/WorldContext.sol#L180-L203) to transfer the correct information|\n|`_msgValue()`|zero|can use [`WorldContextProvider` (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/world/src/WorldContext.sol#L180-L203) to transfer the correct information|\n|Can be used by systems in the root namespace|No (it's a security measure)|Yes|\n\n#### Calling from a root `System`[](#calling-from-a-root-system)\n\nFor [security reasons](/retrospectives/2023-09-12-register-system-vulnerability) the `World` cannot call itself. A `System` in the root namespace runs in the `World` context, and therefore cannot call the `World` either.\n\nðŸš«\n\nYou _could_ use [`delegatecall` (opens in a new tab)](https://docs.soliditylang.org/en/v0.8.16/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries), but you should only do it if it's necessary. A root `System` acts as the `World`, so a `delegatecall` from a root `System` behaves exactly like a `delegatecall` from the `World`. Any contract you `delegatecall` inherits your permissions, in this case unlimited access to the `World` and the ability to change everything.\n\nAn alternative solution is for the root `System` to do exactly what the `World` does with a normal call: check for access permission, run before hook (if configured), call the `System`, and then run the after hook (if configured). To do that, you can use [`SystemCall.callWithHooks()` (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/world/src/SystemCall.sol#L77-L114).\n\nIf you need to specify values for [`_msgSender()`](/world/reference/world-context#_msgsender) and [`_msgValue()`](/world/reference/world-context#_msgvalue) to provide for the called `System`, you can use [`WorldContextProviderLib.callWithContext` (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/world/src/WorldContext.sol#L122-L140). Note that this function is _extremely_ low level, and if you use it you have to process hooks and access control yourself.\n\n#### `SystemSwitch`[](#systemswitch)\n\nIf your `System` needs run both from the root namespace and from other namespaces, you can call other `System`s using [`SystemSwitch` (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/world-modules/src/utils/SystemSwitch.sol).\n\n1. Import `SystemSwitch`.\n    \n    ```\n    import { SystemSwitch } from \"@latticexyz/world-modules/src/utils/SystemSwitch.sol\";\n    ```\n    \n2. Import the interface for the system you wish to call.\n    \n    ```\n    import { IIncrementSystem } from \"../codegen/world/IIncrementSystem.sol\";\n    ```\n    \n3. Call the function using `SystemSwitch.call`. For example, here is how you can call [`IncrementSystem.increment()`](/templates/typescript/contracts#incrementsystemsol).\n    \n    ```\n     uint32 returnValue = abi.decode(\n       SystemSwitch.call(\n         abi.encodeCall(IIncrementSystem.increment, ())\n       ),\n       (uint32)\n     );\n    ```\n    \n    Explanation\n    \n    ```\n    abi.encodeCall(IIncrementSystem.increment, ())\n    ```\n    \n    Use [`abi.encodeCall` (opens in a new tab)](https://docs.soliditylang.org/en/latest/cheatsheet.html#abi-encoding-and-decoding-functions) to create the calldata. The first parameter is a pointer to the function. The second parameter is a [tuple (opens in a new tab)](https://docs.soliditylang.org/en/latest/control-structures.html#destructuring-assignments-and-returning-multiple-values) with the function parameters. In this case, there aren't any.\n    \n    The advantage of `abi.encodeCall` is that it checks the types of the function parameters are correct.\n    \n    ```\n    SystemSwitch.call(\n         abi.encodeCall(...)\n    )\n    ```\n    \n    Using `SystemSwitch.call` with the calldata created by `abi.encodeCall`. `SystemSwitch.call` takes care of figuring out details, such as what type of call to use.\n    \n    ```\n    uint32 retval = abi.decode(\n       SystemSwitch.call(...),\n       (uint32)\n    );\n    ```\n    \n    Use [`abi.decode` (opens in a new tab)](https://docs.soliditylang.org/en/latest/cheatsheet.html#abi-encoding-and-decoding-functions) to decode the call's return value. The second parameter is the data type (or types if there are multiple return values).\n    \n\n## Registering systems[](#registering-systems)\n\nFor a `System` to be callable from a `World` it has to be [registered (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/world/src/modules/init/implementations/WorldRegistrationSystem.sol#L115-L178). Only the [namespace owner](/world/namespaces-access-control#ownership) can register a `System` in a namespace.\n\n`System`s can be registered once per `World`, but the same system can be registered in multiple `World`s. If you need multiple instances of a `System` in the same world, you can deploy the `System` multiple times and register the individual deployments individually.\n\nMessagingExtension.s.sol\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n \nimport { Script } from \"forge-std/Script.sol\";\nimport { console } from \"forge-std/console.sol\";\nimport { IBaseWorld } from \"@latticexyz/world-modules/src/interfaces/IBaseWorld.sol\";\nimport { WorldRegistrationSystem } from \"@latticexyz/world/src/modules/core/implementations/WorldRegistrationSystem.sol\";\n \n// Create resource identifiers (for the namespace and system)\nimport { ResourceId } from \"@latticexyz/store/src/ResourceId.sol\";\nimport { WorldResourceIdLib } from \"@latticexyz/world/src/WorldResourceId.sol\";\nimport { RESOURCE_SYSTEM } from \"@latticexyz/world/src/worldResourceTypes.sol\";\n \n// For registering the table\nimport { Messages, MessagesTableId } from \"../src/codegen/index.sol\";\nimport { IStore } from \"@latticexyz/store/src/IStore.sol\";\nimport { StoreSwitch } from \"@latticexyz/store/src/StoreSwitch.sol\";\n \n// For deploying MessageSystem\nimport { MessageSystem } from \"../src/systems/MessageSystem.sol\";\n \ncontract MessagingExtension is Script {\n  function run() external {\n    uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\");\n    address worldAddress = vm.envAddress(\"WORLD_ADDRESS\");\n    WorldRegistrationSystem world = WorldRegistrationSystem(worldAddress);\n    ResourceId namespaceResource = WorldResourceIdLib.encodeNamespace(bytes14(\"messaging\"));\n    ResourceId systemResource = WorldResourceIdLib.encode(RESOURCE_SYSTEM, \"messaging\", \"MessageSystem\");\n \n    vm.startBroadcast(deployerPrivateKey);\n \n    world.registerNamespace(namespaceResource);\n    StoreSwitch.setStoreAddress(worldAddress);\n    Messages.register();\n    MessageSystem messageSystem = new MessageSystem();\n    world.registerSystem(systemResource, messageSystem, true);\n    world.registerFunctionSelector(systemResource, \"incrementMessage(string)\");\n \n    vm.stopBroadcast();\n  }\n}\n```\n\n`System` registration requires several steps:\n\n1. Create the resource ID for the `System`.\n2. Deploy the `System` contract.\n3. Use [`WorldRegistrationSystem.registerSystem` (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/world/src/modules/init/implementations/WorldRegistrationSystem.sol#L115-L178) to register the `System`. This function takes three parameters:\n    - The ResourceId for the `System`.\n    - The address of the `System` contract.\n    - Access control - whether access to the `System` is public (`true`) or limited to entities with access either to the namespace or the `System` itself (`false`).  \n        \n4. Optionally, register [function selectors](/world/function-selectors) for the `System`.\n\n### Upgrading systems[](#upgrading-systems)\n\nThe namespace owner can upgrade a `System`. This is a two-step process: deploy the contract for the new `System` and then call `registerSystem` with the same `ResourceId` as the old one and the new contract address.\n\nThis upgrade process removes the old `System` contract's access to the namespace, and gives access to the new contract. Any access granted _manually_ to the old `System` is not revoked, nor granted to the upgraded `System`.\n\n**Note:** You _should_ make sure to remove any such manually granted access. MUD access is based on the contract address, so somebody else could register a namespace they'd own, register the old `System` contract as a system in their namespace, and then abuse those permissions (if the `System` has code that can be used for that, of course).\n\nSample code\n\n```\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.24;\n \nimport { Script } from \"forge-std/Script.sol\";\nimport { console } from \"forge-std/console.sol\";\nimport { System } from \"@latticexyz/world/src/System.sol\";\n \nimport { IWorld } from \"../src/codegen/world/IWorld.sol\";\nimport { Counter } from \"../src/codegen/index.sol\";\n \nimport { ResourceId, WorldResourceIdLib, WorldResourceIdInstance } from \"@latticexyz/world/src/WorldResourceId.sol\";\nimport { RESOURCE_SYSTEM } from \"@latticexyz/world/src/worldResourceTypes.sol\";\n \ncontract IncrementSystem2 is System {\n  function increment() public returns (uint32) {\n    uint32 counter = Counter.get();\n    uint32 newValue = counter + 2;\n    Counter.set(newValue);\n    return newValue;\n  }\n}\n \ncontract UpdateASystem is Script {\n  function run() external {\n    address worldAddress = 0xC14fBdb7808D9e2a37c1a45b635C8C3fF64a1cc1;\n \n    // Load the private key from the `PRIVATE_KEY` environment variable (in .env)\n    uint256 deployerPrivateKey = vm.envUint(\"PRIVATE_KEY\");\n \n    // Start broadcasting transactions from the deployer account\n    vm.startBroadcast(deployerPrivateKey);\n \n    // Deploy IncrementSystem2\n    IncrementSystem2 incrementSystem2 = new IncrementSystem2();\n \n    ResourceId systemId = WorldResourceIdLib.encode({\n      typeId: RESOURCE_SYSTEM,\n      namespace: \"\",\n      name: \"IncrementSystem\"\n    });\n \n    IWorld(worldAddress).registerSystem(systemId, incrementSystem2, true);\n \n    vm.stopBroadcast();\n  }\n}\n```\n\nExplanation\n\n```\nimport { ResourceId, WorldResourceIdLib, WorldResourceIdInstance } from \"@latticexyz/world/src/WorldResourceId.sol\";\nimport { RESOURCE_SYSTEM } from \"@latticexyz/world/src/worldResourceTypes.sol\";\n```\n\nTo upgrade a `System` we need the resource ID for it.\n\n```\ncontract IncrementSystem2 is System {\n  function increment() public returns (uint32) {\n    uint32 counter = Counter.get();\n    uint32 newValue = counter + 2;\n    Counter.set(newValue);\n    return newValue;\n  }\n}\n```\n\nThe new `System`. It needs to implement the same `public` functions as the `System` being replaced.\n\n```\n    ...\n \n    // Deploy IncrementSystem2\n    IncrementSystem2 incrementSystem2 = new IncrementSystem2();\n```\n\nDeploy the new `System`.\n\n```\n    ResourceId systemId = WorldResourceIdLib.encode(\n      { typeId: RESOURCE_SYSTEM,\n        namespace: \"\",\n        name: \"IncrementSystem\"\n      });\n```\n\nGet the `ResourceId` for the `System`.\n\n```\n    IWorld(worldAddress).registerSystem(systemId, incrementSystem2, true);\n```\n\nRegister the new `System`. This removes the existing `System` and the access automatically granted to it.\n\n## Access control[](#access-control)\n\nWhen you register a `System`, you can specify whether it is going to be private or public.\n\n- A public `System` has no access control checks, it can be called by anybody. This is the main mechanism for user interaction with a MUD application.\n    \n- A private `System` can only be called by accounts that have access. This access can be the result of:\n    \n    - Access permission to the namespace in which the `System` is registered.\n    - Access permission specifically to the `System`.\n\nNote that `System`s have access to their own namespace by default, so public `System`s can call private `System`s in their namespace.\n\n## Root systems[](#root-systems)\n\nThe `World` uses `call` for systems in other namespaces, but `delegatecall` for those in the root namespace (`bytes14(0)`). As a result, root systems have access to the `World` contract's storage. Because of this access, root systems use [the internal `StoreCore` methods (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/store/src/StoreCore.sol), which are slightly cheaper than calling [the external `IStore` methods (opens in a new tab)](https://github.com/latticexyz/mud/blob/main/packages/store/src/IStore.sol) used by other systems. Note that the table libraries abstract this difference, so normally there is no reason to be concerned about it.\n\nAnother effect of having access to the storage of the `World` is that root systems could, in theory, overwrite any information in any table regardless of access control. Only the [owner of the root namespace](/world/namespaces-access-control) can register root systems. We recommend to only use the root namespace when strictly necessary.\n\n[Tables](/world/tables \"Tables\")[System Hooks](/world/system-hooks \"System Hooks\")\n\n---\n\nMIT 2023 Â© MUD\n\nSystems â€“ MUD","x":-1800,"y":-1826,"width":894,"height":967,"color":"6"},
		{"id":"1a8f587bc0c328ca","type":"text","text":"### Action Plan for Adding Trading and Dynamic Quest Components\n\n1. **Identify and Define Schemas:**\n   - Determine the necessary data structures for Trading and Dynamic Quests.\n   - Define schemas for tables such as `TradeRequest`, `TradeOffer`, `Quest`, `QuestStatus`, etc.\n\n2. **Update Configuration:**\n   - Adjust `mud.config.ts` to include new tables for Trading and Dynamic Quests.\n\n3. **Implement Business Logic:**\n   - Develop the smart contract logic for trading between entities (e.g., sending a trade request, accepting/canceling trades).\n   - Implement dynamic quest logic, such as generating quests, tracking status, and rewarding participants.\n\n4. **Generate Code:**\n   - Utilize `tablegen` CLI to auto-generate table libraries based on the updated configuration.\n\n5. **Testing and Validation:**\n   - Write tests to ensure the correctness of the trading and quest logic.\n   - Validate that the new table structures are correctly storing and retrieving data.\n\n### Updated `mud.config.ts`\n\nHere's how the updated `mud.config.ts` might look:\n\n```typescript\nimport { defineConfig } from \"mud/config\";\n\nexport default defineConfig({\n  // Existing configurations\n\n  // Define new schemas for Trading and Dynamic Quests\n  schemas: {\n    TradeRequest: {\n      requestId: \"bytes32\",\n      requester: \"address\",\n      requestedItem: \"uint256\",\n      quantityRequested: \"uint32\",\n      status: \"uint8\", // 0: Pending, 1: Accepted, 2: Canceled\n    },\n    TradeOffer: {\n      offerId: \"bytes32\",\n      requestId: \"bytes32\",\n      offerer: \"address\",\n      offeredItem: \"uint256\",\n      quantityOffered: \"uint32\",\n    },\n    Quest: {\n      questId: \"bytes32\",\n      questName: \"string\",\n      description: \"string\",\n      reward: \"uint256\",\n      isActive: \"bool\",\n    },\n    QuestStatus: {\n      questId: \"bytes32\",\n      participant: \"address\",\n      status: \"uint8\", // 0: In Progress, 1: Completed, 2: Failed\n    },\n  },\n\n  // Define keys for the new tables\n  keys: {\n    TradeRequest: [\"requestId\"],\n    TradeOffer: [\"offerId\"],\n    Quest: [\"questId\"],\n    QuestStatus: [\"questId\", \"participant\"],\n  },\n\n  // Additional tables for the newly defined schemas\n  tables: {\n    TradeRequest: {\n      schema: {\n        requestId: \"bytes32\",\n        requester: \"address\",\n        requestedItem: \"uint256\",\n        quantityRequested: \"uint32\",\n        status: \"uint8\",\n      },\n      key: [\"requestId\"],\n    },\n    TradeOffer: {\n      schema: {\n        offerId: \"bytes32\",\n        requestId: \"bytes32\",\n        offerer: \"address\",\n        offeredItem: \"uint256\",\n        quantityOffered: \"uint32\",\n      },\n      key: [\"offerId\"],\n    },\n    Quest: {\n      schema: {\n        questId: \"bytes32\",\n        questName: \"string\",\n        description: \"string\",\n        reward: \"uint256\",\n        isActive: \"bool\",\n      },\n      key: [\"questId\"],\n    },\n    QuestStatus: {\n      schema: {\n        questId: \"bytes32\",\n        participant: \"address\",\n        status: \"uint8\",\n      },\n      key: [\"questId\", \"participant\"],\n    },\n  },\n\n  // Additional configuration options...\n});\n```\n\n### Description:\n1. **Schemas**:\n   - `TradeRequest`: Stores information about trade requests.\n   - `TradeOffer`: Stores information about trade offers associated with trade requests.\n   - `Quest`: Stores information about different quests available in the game.\n   - `QuestStatus`: Tracks the status of quests for different participants.\n\n2. **Keys**:\n   - `TradeRequest`, `TradeOffer`, `Quest`, and `QuestStatus`: Defined with appropriate primary keys to uniquely identify each record.\n\n3. **Tables**:\n   - Defines the structure of tables to match the schemas and keys.\n\n4. **Additional Configuration**:\n   - Any other configuration required by the game logic.\n\n### Next Steps:\n1. **Generate Table Libraries**:\n   - Run the `tablegen` CLI to generate the corresponding table libraries.\n\n2. **Implement Business Logic**:\n   - Implement contracts or modules to handle trading and quest logic.\n\n3. **Testing**:\n   - Write comprehensive tests to validate the trading and dynamic quests functionalities.\n\nThis configuration provides a systematic approach to adding new functionalities for trading and dynamic quests in the MUD environment.","x":-1700,"y":-40,"width":695,"height":1552,"color":"6"},
		{"id":"eaede5a5c574fbb0","type":"text","text":"Implementing system contracts for Trading and dynamic quests will require careful consideration of security, state storage, and interactions between different entities. Below are basic implementations for TradingSystem and DynamicQuestSystem contracts.\n\n### Trading System\n```ts\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { System } from \"@latticexyz/world/src/System.sol\";\nimport { Inventory, Item, ItemData } from \"../codegen/index.sol\";\nimport { addressToEntityKey } from \"../addressToEntityKey.sol\";\n\ncontract TradingSystem is System {\n    event TradeExecuted(address from, address to, bytes8 itemId);\n\n    function tradeItem(address to, bytes8 itemId) public {\n        bytes32 fromId = addressToEntityKey(msg.sender);\n        bytes32 toId = addressToEntityKey(to);\n\n        // Check that the sender owns the item\n        require(_ownsItem(fromId, itemId), \"Sender does not own the item\");\n\n        // Transfer the item from sender to the recipient\n        _removeItemFromInventory(fromId, itemId);\n        _addItemToInventory(toId, itemId);\n\n        emit TradeExecuted(msg.sender, to, itemId);\n    }\n\n    function _ownsItem(bytes32 ownerId, bytes8 itemId) internal view returns (bool) {\n        bytes8[] memory itemIds = Inventory.getItemIds(ownerId);\n        for (uint i = 0; i < itemIds.length; i++) {\n            if (itemIds[i] == itemId) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _removeItemFromInventory(bytes32 ownerId, bytes8 itemId) internal {\n        Item.deleteRecord(itemId);\n        Inventory.removeItemId(ownerId, itemId); // Assuming a function that removes specific item ID from the owner's inventory\n    }\n\n    function _addItemToInventory(bytes32 ownerId, bytes8 itemId) internal {\n        Inventory.pushItemIds(ownerId, itemId);\n        Item.set(itemId, ItemData({ itemCount: 1, itemName: \"Item Name\" })); // Presume itemData available from database or other source\n    }\n}\n```\n\n### Dynamic Quests System\n```ts\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { System } from \"@latticexyz/world/src/System.sol\";\nimport { Inventory, Item, ItemData, Quest, QuestData } from \"../codegen/index.sol\";\nimport { addressToEntityKey } from \"../addressToEntityKey.sol\";\n\ncontract DynamicQuestSystem is System {\n    uint public questCounter;\n\n    event QuestCreated(uint questId, string questName, string questDescription, bytes8 rewardItemId);\n    event QuestCompleted(uint questId, address player);\n\n    function createQuest(string memory questName, string memory questDescription, bytes8 rewardItemId) public {\n        questCounter++;\n        Quest.set(questCounter, QuestData({name: questName, description: questDescription, rewardItemId: rewardItemId, isActive: true}));\n\n        emit QuestCreated(questCounter, questName, questDescription, rewardItemId);\n    }\n\n    function completeQuest(uint questId) public {\n        QuestData memory questData = Quest.get(questId);\n        require(questData.isActive, \"Quest is not active\");\n\n        bytes32 playerId = addressToEntityKey(msg.sender);\n        _rewardItemToPlayer(playerId, questData.rewardItemId);\n\n        // Mark quest as completed\n        Quest.set(questId, QuestData({name: questData.name, description: questData.description, rewardItemId: questData.rewardItemId, isActive: false}));\n\n        emit QuestCompleted(questId, msg.sender);\n    }\n\n    function _rewardItemToPlayer(bytes32 playerId, bytes8 rewardItemId) internal {\n        Inventory.pushItemIds(playerId, rewardItemId);\n        Item.set(rewardItemId, ItemData({ itemCount: 1, itemName: \"Reward Item\" })); // Presume reward item data available\n    }\n}\n```\n\n### Notes:\n- These implementations assume the existence of respective getter and setter methods in Inventory, Item, and Quest contracts.\n- You may need to tailor the code according to the actual structure and methods of your `Inventory`, `Item`, and `Quest` entities.\n- Proper security checks should be enforced to ensure that only authorized actions are allowed.\n- The dynamic quest system adds and completes quests, rewarding players upon completion. It assumes a basic mechanism for item management and quest tracking.\n- You should also ensure proper error handling and edge cases checks for production-level contracts, such as non-existent item IDs, overflow checks, and correct state transitions.","x":-960,"y":40,"width":1299,"height":1180,"color":"6"},
		{"id":"95c2e49437ec7bab","type":"text","text":"Implement the dynamic quest and trading on the system calls","x":-960,"y":-660,"width":449,"height":313,"color":"4"},
		{"id":"1d567e634df436c3","type":"text","text":"```ts\nimport { ClientComponents } from \"./createClientComponents\";\nimport { SetupNetworkResult } from \"./setupNetwork\";\nimport { getComponentValue } from \"@latticexyz/recs\";\nimport { uuid } from \"@latticexyz/utils\";\nimport { toast } from \"react-hot-toast\";\nimport { usePlayerStore } from \"~~/services/store/playerStore\";\n\nexport type SystemCalls = ReturnType<typeof createSystemCalls>;\n\nexport function createSystemCalls(\n  { playerEntity, worldContract, waitForTransaction }: SetupNetworkResult,\n  { Player, Lore, Inventory, Item }: ClientComponents,\n) {\n  const spawn = async () => {\n    if (!playerEntity) {\n      throw new Error(\"no player\");\n    }\n    const canSpawn = getComponentValue(Player, playerEntity)?.value !== true;\n    const playerName = usePlayerStore.getState().playerName;\n    const lore = usePlayerStore.getState().lore;\n\n    if (!canSpawn) {\n      throw new Error(\"already spawned\");\n    }\n\n    const playerId = uuid();\n    Player.addOverride(playerId, {\n      entity: playerEntity,\n      value: { value: true },\n    });\n\n    const args = {\n      x: 0,\n      y: 0,\n      health: 100,\n      name: playerName,\n    };\n\n    toast.loading(\"Spawning player...\");\n    try {\n      const tx = await worldContract.write.spawnPlayer([args, lore]);\n      await waitForTransaction(tx);\n    } catch (error) {\n      console.error(\"Spawn transaction failed:\", error);\n    } finally {\n      setTimeout(() => {\n        Player.removeOverride(playerId);\n        toast.dismiss();\n        toast.success(`Player spawned! ${playerName}`);\n      }, 1000);\n    }\n  };\n\n  const addItemToInventory = async () => {\n    toast.loading(\"Adding item...\");\n    try {\n      const tx = await worldContract.write.addItemToInventory([1]);\n      await waitForTransaction(tx);\n      toast.success(\"Item added!\");\n    } catch (error) {\n      console.error(\"Add item transaction failed:\", error);\n      toast.error(\"Failed to add item.\");\n    } finally {\n      toast.dismiss();\n    }\n  };\n\n  const removeItemFromInventory = async (ownerId: string, itemId: string) => {\n    toast.loading(\"Removing item...\");\n    try {\n      const tx = await worldContract.write.removeItemFromInventory([ownerId, itemId]);\n      await waitForTransaction(tx);\n      toast.success(\"Item removed!\");\n    } catch (error) {\n      console.error(\"Remove item transaction failed:\", error);\n      toast.error(\"Failed to remove item.\");\n    } finally {\n      toast.dismiss();\n    }\n  };\n\n  return {\n    spawn,\n    addItemToInventory,\n    removeItemFromInventory,\n  };\n}\n\n```","x":-1591,"y":-600,"width":477,"height":330,"color":"4"},
		{"id":"65ba7afbbc415bfa","type":"text","text":"To implement dynamic quest and trading functionality, you need to define the operations to create quests, complete quests, and trade items. Hereâ€™s how you could extend the system calls with these functionalities:\n\n### Define Quest and Trading Functions\n\n1. **`createQuest`** - Create a new quest.\n2. **`completeQuest`** - Mark a quest as complete.\n3. **`tradeItem`** - Facilitate trading of items between two players.\n\nHere's an example of how to add these functions:\n\n```ts\nimport { ClientComponents } from \"./createClientComponents\";\nimport { SetupNetworkResult } from \"./setupNetwork\";\nimport { getComponentValue } from \"@latticexyz/recs\";\nimport { uuid } from \"@latticexyz/utils\";\nimport { toast } from \"react-hot-toast\";\nimport { usePlayerStore } from \"~~/services/store/playerStore\";\n\nexport type SystemCalls = ReturnType<typeof createSystemCalls>;\n\nexport function createSystemCalls(\n  { playerEntity, worldContract, waitForTransaction }: SetupNetworkResult,\n  { Player, Lore, Inventory, Item, Quest, Trading }: ClientComponents\n) {\n  \n  const handleTransaction = async (\n    transactionFn: () => Promise<any>,\n    loadingMessage: string,\n    successMessage: string,\n    errorMessage: string\n  ) => {\n    toast.loading(loadingMessage);\n\n    try {\n      const tx = await transactionFn();\n      await waitForTransaction(tx);\n      toast.success(successMessage);\n    } catch (error) {\n      console.error(\"Transaction failed:\", error);\n      toast.error(errorMessage);\n    } finally {\n      toast.dismiss();\n    }\n  };\n\n  const spawn = async () => {\n    if (!playerEntity) {\n      throw new Error(\"no player\");\n    }\n\n    const canSpawn = getComponentValue(Player, playerEntity)?.value !== true;\n    const playerName = usePlayerStore.getState().playerName;\n    const lore = usePlayerStore.getState().lore;\n\n    if (!canSpawn) {\n      throw new Error(\"already spawned\");\n    }\n\n    const playerId = uuid();\n    Player.addOverride(playerId, {\n      entity: playerEntity,\n      value: { value: true },\n    });\n\n    toast.loading(\"Spawning player...\");\n\n    try {\n      const args = {\n        x: 0,\n        y: 0,\n        health: 100,\n        name: playerName,\n      };\n      const tx = await worldContract.write.spawnPlayer([args, lore]);\n      await waitForTransaction(tx);\n      toast.success(`Player spawned! ${playerName}`);\n    } catch (error) {\n      console.error(\"Spawn transaction failed:\", error);\n      toast.error(\"Failed to spawn player.\");\n    } finally {\n      setTimeout(() => {\n        Player.removeOverride(playerId);\n        toast.dismiss();\n      }, 1000);\n    }\n  };\n\n  const addItemToInventory = async () => {\n    await handleTransaction(\n      () => worldContract.write.addItemToInventory([1]),\n      \"Adding item...\",\n      \"Item added!\",\n      \"Failed to add item.\"\n    );\n  };\n\n  const removeItemFromInventory = async (ownerId: string, itemId: string) => {\n    await handleTransaction(\n      () => worldContract.write.removeItemFromInventory([ownerId, itemId]),\n      \"Removing item...\",\n      \"Item removed!\",\n      \"Failed to remove item.\"\n    );\n  };\n\n  const createQuest = async (name: string, description: string, reward: number) => {\n    await handleTransaction(\n      () => worldContract.write.createQuest([name, description, reward]),\n      \"Creating quest...\",\n      \"Quest created!\",\n      \"Failed to create quest.\"\n    );\n  };\n\n  const completeQuest = async (questId: string) => {\n    await handleTransaction(\n      () => worldContract.write.completeQuest([questId]),\n      \"Completing quest...\",\n      \"Quest completed!\",\n      \"Failed to complete quest.\"\n    );\n  };\n\n  const tradeItem = async (from: string, to: string, itemId: string) => {\n    await handleTransaction(\n      () => worldContract.write.tradeItem([from, to, itemId]),\n      \"Trading item...\",\n      \"Item traded!\",\n      \"Failed to trade item.\"\n    );\n  };\n\n  return {\n    spawn,\n    addItemToInventory,\n    removeItemFromInventory,\n    createQuest,\n    completeQuest,\n    tradeItem,\n  };\n}\n```\n\n### Key Additions:\n\n1. **`createQuest`**:\n    - Initiates a transaction to create a new quest using the `worldContract`.\n    - Waits for the transaction to be completed and displays appropriate toast notifications.\n\n2. **`completeQuest`**:\n    - Marks a quest as completed using the `worldContract`.\n    - Handles transaction completion and displays toast notifications.\n\n3. **`tradeItem`**:\n    - Facilitates item trading between two players.\n    - Uses `worldContract` for initiating the trade transaction and handles success, fail cases with toast notifications.\n\n### Integration with Smart Contracts\nMake sure that the smart contract on the blockchain has these functions:\n- `spawnPlayer`\n- `addItemToInventory`\n- `removeItemFromInventory`\n- `createQuest`\n- `completeQuest`\n- `tradeItem`\n\nEach of these should correctly receive and handle the parameters and perform the actions as implemented above. This design leverages a simplistic approach by collating common code into helper methods and making each function more straightforward to reason about and maintain.\n\nFeel free to adapt parameters based on the actual contract requirements and data structures in use. If more specific state management or other operations are required, each function can be by extending the helper function as needed.","x":-1114,"y":352,"width":1800,"height":1160,"color":"6"}
	],
	"edges":[
		{"id":"398e4d375a633c1f","fromNode":"5415a6e4c950a6ea","fromSide":"bottom","toNode":"1d567e634df436c3","toSide":"top"},
		{"id":"371b536626a6f347","fromNode":"eaede5a5c574fbb0","fromSide":"top","toNode":"1d567e634df436c3","toSide":"bottom"},
		{"id":"c23ea2ec2ceb1f4b","fromNode":"1a8f587bc0c328ca","fromSide":"top","toNode":"1d567e634df436c3","toSide":"bottom"},
		{"id":"911cfb72e5c5e7b0","fromNode":"95c2e49437ec7bab","fromSide":"right","toNode":"65ba7afbbc415bfa","toSide":"left"},
		{"id":"5b825ef413ee2717","fromNode":"1d567e634df436c3","fromSide":"right","toNode":"95c2e49437ec7bab","toSide":"left"}
	]
}